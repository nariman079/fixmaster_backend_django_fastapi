# File: ./manage.py
#!/usr/bin/env python 
"""Django's command-line utility for administrative tasks."""

import os
import sys
from dotenv import load_dotenv

load_dotenv()


def main():
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()


# File: ./test.py
import os

project_dir = '.'  # Корень проекта
output_file = 'project_code.txt'
exclude_dirs = {'.venv','venv', '__pycache__', '.git', '.idea', '.mypy_cache', '.pytest_cache'}

extra_files = {'Dockerfile', 'docker-compose.yml', 'docker-compose.yaml'}
nginx_dirs = {'nginx'}
nginx_extensions = {'.conf'}

def should_include_file(file_path, file_name):
    if file_name.endswith('.py') and not file_name.endswith('.pyc'):
        return True
    if file_name in extra_files:
        return True
    if any(file_name.endswith(ext) for ext in nginx_extensions):
        return True
    if 'nginx' in file_path.split(os.sep):  # если файл внутри папки nginx
        return True
    return False

with open(output_file, 'w', encoding='utf-8') as outfile:
    for root, dirs, files in os.walk(project_dir):
        # Исключаем ненужные директории
        dirs[:] = [d for d in dirs if d not in exclude_dirs]

        for file in files:
            file_path = os.path.join(root, file)
            if should_include_file(file_path, file):
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        code = f.read()
                        outfile.write(f'# File: {file_path}\n')
                        outfile.write(code + '\n\n')
                except Exception as e:
                    print(f"Ошибка при чтении {file_path}: {e}")


# File: ./Dockerfile
FROM python:3.11
ENV PYTHONUNBUFFERED=1
RUN pip install poetry
WORKDIR /app/
COPY poetry.lock pyproject.toml /app/
RUN poetry config virtualenvs.create false && poetry install
COPY . /app/


# File: ./docker-compose.yml
version: '3'

services:
  # Redis
  redis:
    image: 'redis:alpine'
    restart: always
    command: redis-server
    container_name: 'Redis'
    volumes:
      - redis:/data
    network_mode: host
  # Django
  app:
    build: .
    restart: always
    container_name: 'Backend'
    command: /bin/bash -c "poetry run python manage.py collectstatic --noinput && poetry run python manage.py migrate && poetry run uvicorn config.asgi:application --host 0.0.0.0 --port 8000 --workers 4"
    volumes:
      - .:/app
      - static:/app/static
      - media:/app/media
    env_file:
      - .env
    depends_on:
      - redis
    ports:
      - 8000:8000
    network_mode: host
  # Celery
  celery:
    build: .
    command:  celery -A config worker -l info
    env_file:
      - .env
    depends_on:
      - app
      - redis
    restart: always
    volumes:
      - static:/app/static
      - media:/app/media
    network_mode: host
  # Nginx
  nginx:
    image: nginx:latest
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/default.template:/etc/nginx/conf.d/default.conf.template
      - /etc/letsencrypt:/etc/letsencrypt
      - /home/www:/home/www
      - static:/app/static
      - media:/app/media
    command: bash -c "envsubst '$${HOST}' < /etc/nginx/conf.d/default.conf.template > /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'"
    env_file:
      - .env
    environment:
      - HOST=${HOST}
    depends_on:
      - app
    network_mode: host

volumes:
  static:
  media:
  redis:




# File: ./src/urls.py
from django.urls import path

from src.views.order_views import OrderCreateView, FreeBookingView
from src.views.organization_views import (
    OrganizationListView,
    OrganizationDetailView,
    OrganizationTypeListView,
    SearchOrganization,
    ServiceListView,
    MasterListView,
)

urlpatterns = [
    path("order/create/", OrderCreateView.as_view()),
    path("booking/get-free-times/", FreeBookingView.as_view()),
    path("organizations/", OrganizationListView.as_view()),
    path("organizations/<int:organization_id>/", OrganizationDetailView.as_view()),
    path("organization/search/", SearchOrganization.as_view()),
    path("organizations-types/", OrganizationTypeListView.as_view()),
    path("services/", ServiceListView.as_view()),
    path("master/services/", MasterListView.as_view()),
]


# File: ./src/__init__.py


# File: ./src/tasks.py
import os

from celery import shared_task
from telebot import TeleBot
from django.utils import timezone

from src.models import Order

telegram_bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
bot = TeleBot(telegram_bot_token)


@shared_task
def send_message_on_telegram(chat_id, message):
    """Async sending message on telegram chat"""
    bot.send_message(chat_id=chat_id, text=message)


@shared_task(bind=True, default_retry_delay=60, max_retries=None)
def auto_checking_order(self, order_id: int):
    """Checking order on end time"""
    now_date, now_time = timezone.now().date(), timezone.now().time()
    order: Order = Order.objects.get(id=order_id)

    if order.begin_date > now_date:
        end_time = (order.begin_time.min - now_time.min).total_seconds()
        if end_time <= 60:
            # Send message, 1 hour before the start
            send_message_on_telegram(
                chat_id=order.customer.telegram_id, message=f"Message {end_time}"
            )
            self.retry(countdown=30 * 60)
        elif end_time <= 30:
            # Send message, half an hour before the start
            send_message_on_telegram(
                chat_id=order.customer.telegram_id, message=f"Message {end_time}"
            )
            self.retry(countdown=15 * 60)
        elif end_time <= 15:
            # Send message, 15 min before the start
            send_message_on_telegram(
                chat_id=order.customer.telegram_id, message=f"Message {end_time}"
            )
            self.retry(countdown=3 * 60)
        elif end_time <= 3:
            send_message_on_telegram(
                chat_id=order.customer.telegram_id, message=f"Message {end_time}"
            )


# File: ./src/views.py


# File: ./src/apps.py
from django.apps import AppConfig


class SrcAppConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "src"
    verbose_name = "СУБ"


# File: ./src/admin/orders_admin.py


# File: ./src/admin/__init__.py
"""
Initial admins
"""

from src.admin.organization_admin import content_management_admin

__all__ = ("content_management_admin",)


# File: ./src/admin/organization_admin.py
"""
Setting up admin panels
"""

from django.contrib import admin
from django.utils.html import format_html

from src.models import (
    Organization,
    OrganizationType,
    Image,
    Service,
    Master,
    Customer,
    Moderator,
    Booking,
)


class ContentManagementArea(admin.AdminSite):
    """
    Customization admin panel for content management
    """

    site_header = "Управление контентом"
    site_title = "Контент сайта"


content_management_admin = ContentManagementArea(name="Content management")


# Tabular inlines
class MasterServiceTabularInilne(admin.TabularInline):
    model = Service


class OrganizationMasterInlinel(admin.TabularInline):
    model = Master


class OrganizationImageInlinel(admin.StackedInline):
    model = Image

    list_display = ("image",)
    classes = ["collapse"]


# Model admins
class MasterAdmin(admin.ModelAdmin):
    """Master model admin"""

    list_display = ("name", "surname", "gender")
    list_display_links = ("name",)

    inlines = [MasterServiceTabularInilne]


class OrganizationAdmin(admin.ModelAdmin):
    """Master model admin"""

    list_display = ("title", "contact_phone", "organization_type")
    list_display_links = ("title",)
    inlines = [OrganizationMasterInlinel, OrganizationImageInlinel]


class CustomerAdmin(admin.ModelAdmin):
    list_display = ("username", "telegram_id", "phone")
    list_display_links = ("username",)


class ImageAdmin(admin.ModelAdmin):
    list_display = ("get_image_url", "organization", "priority")
    list_filter = ("organization",)

    def get_image_url(self, obj: Image):
        return format_html(f'<img src="{obj.image_url}" width="300px">')


content_management_admin.register(Moderator)
content_management_admin.register(Master, MasterAdmin)
content_management_admin.register(Organization, OrganizationAdmin)
content_management_admin.register(OrganizationType)
content_management_admin.register(Customer, CustomerAdmin)
content_management_admin.register(Booking)
content_management_admin.register(Image, ImageAdmin)


# File: ./src/admin/application_admin.py


# File: ./src/views/__init__.py


# File: ./src/views/organization_views.py
from drf_spectacular.types import OpenApiTypes
from drf_spectacular.utils import extend_schema, OpenApiParameter
from rest_framework.exceptions import ValidationError
from rest_framework.response import Response
from rest_framework.views import APIView

from src.models import Organization
from src.serializers.organization_serializers import (
    OrganizationSerializer,
    OrganizationDetailSerializer,
)
from src.services.organization_services import (
    get_organization_types,
    search_organization,
    get_services_title,
    get_master_services,
)


class OrganizationListView(APIView):
    """
    Controller for the organization's list page

    accessed methods: GET,
    """

    serializer_class = OrganizationSerializer

    def get(self, request, *args, **kwargs):
        try:
            organization_queryset = Organization.objects.filter(
                **self.request.query_params.dict()
            ).filter(is_verified=True)
            organization_serializer = OrganizationSerializer(
                instance=organization_queryset,
                many=True,
                context={"request": self.request},
            )

            return Response(
                {
                    "message": "All organizations success received",
                    "success": True,
                    "data": organization_serializer.data,
                }
            )
        except ValueError as ex:
            raise ValidationError(ex.args, code=400)


class OrganizationDetailView(APIView):
    """
    Controller for the detailed organization page

    accessed methods: GET,
    path param: organization_id
    """

    def get(self, request, organization_id: int, *args, **kwargs):
        try:
            organization = Organization.objects.get(id=organization_id)
            organization_serializer = OrganizationDetailSerializer(
                instance=organization, context={"request": self.request}
            )

            return Response(
                {
                    "message": "Organization detail success received",
                    "success": True,
                    "data": organization_serializer.data,
                },
                status=200,
            )
        except Organization.DoesNotExist:
            return Response(
                {
                    "message": "Such organization does not exist",
                    "success": False,
                    "data": [],
                },
                status=404,
            )


class OrganizationTypeListView(APIView):
    def get(self, *args, **kwargs):
        """Получение списка типов организаций"""
        return get_organization_types()


class ServiceListView(APIView):
    """
    Controller for services list
    """

    def get(self, *args, **kwargs):
        """Получение списка услуг"""
        return get_services_title()


class SearchOrganization(APIView):
    @extend_schema(
        description="Search organization",
        methods=["GET"],
        parameters=[
            OpenApiParameter(
                name="search",
                type=OpenApiTypes.STR,
                location=OpenApiParameter.QUERY,
                description="Search text",
            ),
        ],
    )
    def get(self, *args, **kwargs):
        """
        search: query params from url ".../organization/?search="
        search: string
        """
        if text := self.request.query_params.get("search"):
            return search_organization(text)

        return Response(
            {"message": "Запрос успешно выполнен", "success": True, "data": []}
        )


class MasterListView(APIView):
    def get(self, *args, **kwargs) -> Response:
        """Получаем все услуги мастера"""
        return get_master_services(self.request.query_params.get("master_id", 0))


# File: ./src/views/order_views.py
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.request import Request

from src.serializers.order_serializers import OrderSerializer, BookingSerializer
from src.services.order_services import OrderCreateSrv, FreeBookingSrv


class OrderCreateView(APIView):
    serializer_class = OrderSerializer

    def post(self, request, *args, **kwargs) -> Response:
        """POST handler for creating order and booking"""
        self.request: Request
        serializer = OrderSerializer(data=self.request.data)
        serializer.is_valid(raise_exception=True)

        if isinstance(serializer.validated_data, dict):
            print(serializer)
            order_create_srv = OrderCreateSrv(
                serializer_validate_data=serializer.validated_data,
                serialzier_data=serializer.data,
            )
            return order_create_srv.execute()

        return Response(
            {
                "message": "Bad error",
                "success": False,
                "data": [],
            },
            status=422,
        )


class FreeBookingView(APIView):
    serializer_class = BookingSerializer

    def post(self, request, *args, **kwargs) -> Response:
        """POST handler for creating order and booking"""
        self.request: Request
        serializer = BookingSerializer(data=self.request.data)
        serializer.is_valid(raise_exception=True)

        if isinstance(serializer.validated_data, dict):
            free_booking_src = FreeBookingSrv(
                serializer_validated_data=serializer.validated_data,
            )
            return free_booking_src.execute()

        return Response(
            {
                "message": "Bad error",
                "success": False,
                "data": [],
            },
            status=422,
        )


# File: ./src/models/image_models.py
"""
Image models in project
"""

from django.db import models


class Image(models.Model):
    """
    Изображения
    """

    class Meta:
        verbose_name = "Изображение"
        verbose_name_plural = "Изображения"

    organization = models.ForeignKey("src.Organization", on_delete=models.CASCADE)
    image = models.ImageField("Изображение", upload_to="images/", null=True, blank=True)
    image_url = models.CharField(max_length=700, null=True, blank=True)
    priority = models.IntegerField("Приоритет", default=0)

    def __str__(self):
        return str(self.pk)


# File: ./src/models/order_models.py
from django.db import models
from src.enums import statuses


class Booking(models.Model):
    """Брони мастеров"""

    class Meta:
        verbose_name = "Бронирование"
        verbose_name_plural = "Бронирование"

    booking_date = models.DateField(
        "Дата бронирования",
    )
    booking_time = models.TimeField(
        "Время бронирования",
    )
    booking_end_time = models.TimeField(
        "Длительность процедуры",
    )
    master = models.ForeignKey(
        "src.Master",
        on_delete=models.CASCADE,
    )
    customer = models.ForeignKey(
        "src.Customer", on_delete=models.CASCADE, null=True, blank=True
    )

    def __str__(self):
        return str(self.master)


class Order(models.Model):
    """Заказы"""

    class Meta:
        verbose_name = "Заказ"
        verbose_name_plural = "Заказы"

    begin_date = models.DateField(
        "Дата начала",
    )
    begin_time = models.TimeField(
        "Время начала",
    )
    length_time = models.IntegerField(
        "Длительность процедуры", null=True, blank=True, editable=False
    )
    status = models.CharField(
        "Статус", max_length=20, choices=statuses.CHOICES_STATUS, default="new"
    )
    customer = models.ForeignKey(
        "src.Customer",
        on_delete=models.SET_NULL,
        verbose_name="Клиент",
        null=True,
        blank=True,
    )
    customer_phone = models.CharField("Номер телефона клиента", max_length=30)
    customer_name = models.CharField("Имя клиента", max_length=60)
    customer_notice = models.CharField(
        "Коментарий", max_length=120, null=True, blank=True
    )
    payment_id = models.CharField(max_length=200, default=" ")
    payment_link = models.CharField(max_length=500, default=" ")
    services = models.ManyToManyField(
        "src.Service",
    )

    def __str__(self):
        return str(self.customer_phone)


# File: ./src/models/__init__.py
"""
Initial all models
"""

from src.models.organization_models import (
    Organization,
    Customer,
    Service,
    OrganizationType,
    Master,
    Moderator,
)
from src.models.image_models import Image
from src.models.order_models import Order, Booking

__all__ = (
    "Image",
    "Order",
    "Booking",
    "Organization",
    "Customer",
    "Service",
    "Organization",
    "Master",
    "OrganizationType",
    "Moderator",
)


# File: ./src/models/organization_models.py
import random
import uuid

from django.db import models
from src.enums import statuses


class OrganizationType(models.Model):
    """Типы орзанизаций"""

    class Meta:
        verbose_name = "Тип организации"
        verbose_name_plural = "Типы организаций"

    title = models.CharField(verbose_name="Типы оргинизаций", max_length=255)

    def __str__(self):
        return self.title


class Organization(models.Model):
    """
    Модель "Организация"
    """

    class Meta:
        verbose_name = "Салон"
        verbose_name_plural = "Салоны"

    telegram_id = models.CharField("ID Телеграм", max_length=30, editable=False)
    title = models.CharField(
        "Название",
        max_length=30,
    )
    main_image = models.ImageField(
        "Заглавное изображение", upload_to="business", null=True, blank=True
    )
    main_image_url = models.CharField(max_length=400, null=True, blank=True)
    address = models.CharField(
        "Адрес",
        max_length=30,
    )
    contact_phone = models.CharField(
        "Номер телефона",
        max_length=30,
    )
    time_begin = models.TimeField(
        "Начало рабочего дня",
    )
    time_end = models.TimeField(
        "Конец рабочего дня",
    )
    work_schedule = models.CharField("График работы", max_length=30)
    organization_type = models.ForeignKey(
        "src.OrganizationType", on_delete=models.PROTECT
    )
    is_verified = models.BooleanField("Верифицирован", default=False)

    def __str__(self):
        return self.title


class Master(models.Model):
    """
    Модель "Мастер"
    """

    class Meta:
        verbose_name = "Мастер"
        verbose_name_plural = "Мастера"

    telegram_id = models.CharField(
        "ID Телеграм",
        max_length=30,
        default="web_user",
    )
    code = models.CharField(
        "Код для регистрации", max_length=200, null=True, blank=True
    )
    name = models.CharField(
        "Имя",
        max_length=30,
    )
    surname = models.CharField(
        "Фамилия",
        max_length=30,
    )
    image = models.ImageField("Изображние", upload_to="master", null=True, blank=True)
    image_url = models.CharField(
        "Ссылка на изображение", max_length=255, null=True, blank=True
    )
    gender = models.CharField(
        "Пол", max_length=30, choices=statuses.CHOICES_GENDER, default="MEN", blank=True
    )
    organization = models.ForeignKey(
        Organization, on_delete=models.CASCADE, verbose_name="Организация"
    )
    is_verified = models.BooleanField("Верифицирован", default=False)

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        if self.pk:
            pass
        else:
            self.code = uuid.uuid4().__str__()
        return super().save(*args, **kwargs)


class Service(models.Model):
    """
    Модель "Услуга мастера"
    """

    class Meta:
        verbose_name = "Услуга"
        verbose_name_plural = "Услуги"

    master = models.ForeignKey(
        "src.Master",
        on_delete=models.CASCADE,
    )
    title = models.CharField("Название", max_length=30)
    short_description = models.CharField(
        "Короткое описание", max_length=150, null=True, blank=True
    )
    price = models.PositiveIntegerField(
        "Стоимость",
    )
    min_time = models.IntegerField(
        "Минимальная длительность процедуры",
    )

    def __str__(self):
        return self.title


class Customer(models.Model):
    """
    Модель "Клиент"
    """

    class Meta:
        verbose_name = "Клиент"
        verbose_name_plural = "Клиенты"

    telegram_id = models.CharField("ID Телеграм", max_length=30, default="default-user")
    phone = models.CharField(
        "Номер телефона", max_length=30, null=True, blank=True, unique=True
    )
    username = models.CharField(
        "Имя пользователя telegram", max_length=30, null=True, blank=True
    )
    name = models.CharField("Имя пользователя", max_length=250, null=True, blank=True)
    additional_info = models.CharField(
        "Дополнительная информация", max_length=255, null=True, blank=True
    )
    code = models.CharField(
        "Код для регистрации", max_length=255, null=True, blank=True
    )
    master = models.ForeignKey(
        "src.Master", on_delete=models.SET_NULL, null=True, blank=True
    )
    is_verified = models.BooleanField("Верифицированный клиент", default=False)

    def __str__(self):
        return self.username or self.name

    def save(self, *args, **kwargs):
        if self.pk:
            pass
        else:
            self.code = uuid.uuid4().__str__()
        super().save(*args, **kwargs)


class Moderator(models.Model):
    class Meta:
        verbose_name = "Модераторы"

    telegram_id = models.CharField("ID Телеграм", max_length=30, default="default-user")
    login = models.CharField("Логин", max_length=30, unique=True)
    code = models.CharField("Код", max_length=30, null=True, blank=True)

    def save(self, *args, **kwargs):
        if self.pk:
            pass
        else:
            self.code = random.randint(10000, 99999)
        return super().save(*args, **kwargs)

    def __str__(self):
        return self.login


# File: ./src/tasks/__init__.py
from src.tasks.notification_tasks import (
    send_message_telegram_on_master,
    send_message_on_moderator_about_organization,
    send_is_verified_organization,
    send_message_about_verify_master,
    send_message_about_verify_customer,
)
from src.tasks.order_tasks import change_status_order

__all__ = (
    "send_message_telegram_on_master",
    "change_status_order",
    "send_message_on_moderator_about_organization",
    "send_message_about_verify_master",
    "send_message_about_verify_customer",
    "send_is_verified_organization",
)


# File: ./src/tasks/notification_tasks.py
from celery import shared_task
from telebot import types

from bot.config import master_bot, moderator_bot, organization_bot
from src.models import Master, Organization, Moderator, Customer


def callback_verify_true_organization(organization_id: int) -> str:
    return f"organization_verify_true_{organization_id}"


def callback_verify_false_organization(organization_id: int) -> str:
    return f"organization_verify_false_{organization_id}"


def callback_verify_organization(organization_id: int, is_verify: bool) -> str:
    return f"organization_verify_{'true' if is_verify else 'false'}_{organization_id}"


def get_moderator_for_send_message() -> Moderator:
    return Moderator.objects.first()


@shared_task
def send_message_telegram_on_master(
    master_id: int,
    client_phone_number: str,
    booking_date: str,
    booking_time: str,
):
    """
    Отправка сообщения Мастеру о бронировании
    """
    master = Master.objects.get(id=master_id)

    text = (
        f"У вас новая бронь\n"
        f"Клиент: {client_phone_number}\n"
        f"Дата: {booking_date}\n"
        f"Время: {booking_time}"
    )

    master_bot.send_message(chat_id=master.telegram_id, text=text)


@shared_task
def send_message_about_verify_master(
    master_id: int,
):
    """
    Отправка сообщения Мастеру о бронировании
    """
    master = Master.objects.get(id=master_id)
    text = f"✅ Мастер {master.name} {master.surname} зарегистрировался в системе \n"
    organization_bot.send_message(chat_id=master.organization.telegram_id, text=text)


@shared_task
def send_message_about_verify_customer(master_id: int, customer_id: int):
    """
    Отправка сообщения Мастеру о бронировании
    """
    customer = Customer.objects.get(telegram_id=customer_id)
    text = (
        f"✅ Клиент {customer.username} {customer.name} зарегистрировался в системе \n"
    )
    master_bot.send_message(chat_id=master_id, text=text)


@shared_task
def send_message_on_moderator_about_organization(organization_id: int):
    """Отправка сообщения модератору о регистрации новой организации"""
    organization = Organization.objects.get(pk=organization_id)
    moderator = get_moderator_for_send_message()

    message = f"""Новая заявка на верификацию!🟩🟩🟩
Название: {organization.title}
Адрес: {organization.address}
Номер телефона: {organization.contact_phone}
Тип огранизации: {organization.organization_type.title}
Начало рабочего дня: {organization.time_begin}
Конец рабочего дня: {organization.time_end}\n
Ссылка на галерею: https://booking.fix-mst.ru/admin/src/image/?organization__id__exact={organization.pk}"""

    moderator_inline_markup = types.InlineKeyboardMarkup()
    verify_true_button = types.InlineKeyboardButton(
        "✅ Верифицировать",
        callback_data=callback_verify_organization(organization_id, True),
    )
    verify_false_button = types.InlineKeyboardButton(
        "❌ Не верифицировать",
        callback_data=callback_verify_organization(organization_id, False),
    )
    moderator_inline_markup.add(verify_true_button)
    moderator_inline_markup.add(verify_false_button)
    moderator_bot.send_message(
        chat_id=moderator.telegram_id,
        text=message,
        reply_markup=moderator_inline_markup,
    )


@shared_task()
def send_is_verified_organization(
    organization_id: int,
    is_verify: bool,
):
    """Отправка сообщения о регистрации новой организации"""
    organization = Organization.objects.get(pk=organization_id)
    if is_verify:
        message = """Хорошая новость! ❇️❇️❇️
Ваша организация была верифицировна.
Теперь вы можете добавлять мастеров и услуг.
        """
        organization_menu_markup = types.ReplyKeyboardMarkup()

        master_list = types.KeyboardButton("📃 Список мастеров")
        client_list = types.KeyboardButton("👥 Список клиентов")
        add_master = types.KeyboardButton("➕ Добавить мастера")

        organization_menu_markup.add(master_list)
        organization_menu_markup.add(client_list)
        organization_menu_markup.add(add_master)

        organization_bot.send_message(
            chat_id=organization.telegram_id,
            text=message,
            reply_markup=organization_menu_markup,
        )
    else:
        message = (
            "Ваша организация не прошла верификацию!‼️\n"
            "Заполните данные еще раз - /start"
        )
        organization_bot.send_message(
            chat_id=organization.telegram_id,
            text=message,
        )


# File: ./src/tasks/order_tasks.py
from celery import shared_task

from src.models import Order


@shared_task
def change_status_order(order_id: int, new_status: str):
    """Изменение статуса заказа или брони"""
    order = Order.objects.get(id=order_id)
    order.status = new_status
    order.save()


# File: ./src/filters/__init__.py


# File: ./src/filters/organization_filters.py
import django_filters
from src.models import Organization


class OrganizationFilter(django_filters.FilterSet):
    class Meta:
        model = Organization
        exclude = ("main_image",)


# File: ./src/migrations/0022_customer_name_alter_customer_username.py
# Generated by Django 5.0.6 on 2024-06-09 22:39

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0021_booking_customer"),
    ]

    operations = [
        migrations.AddField(
            model_name="customer",
            name="name",
            field=models.CharField(
                blank=True, max_length=30, null=True, verbose_name="Имя пользователя"
            ),
        ),
        migrations.AlterField(
            model_name="customer",
            name="username",
            field=models.CharField(
                blank=True,
                max_length=30,
                null=True,
                verbose_name="Имя пользователя telegram",
            ),
        ),
    ]


# File: ./src/migrations/0002_rename_addidional_info_customer_additional_info_and_more.py
# Generated by Django 5.0.6 on 2024-05-22 13:58

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0001_initial"),
    ]

    operations = [
        migrations.RenameField(
            model_name="customer",
            old_name="addidional_info",
            new_name="additional_info",
        ),
        migrations.AddField(
            model_name="customer",
            name="user_keyword",
            field=models.CharField(
                blank=True, max_length=30, null=True, verbose_name="Слово пароль"
            ),
        ),
        migrations.AlterField(
            model_name="customer",
            name="phone",
            field=models.CharField(
                blank=True,
                max_length=30,
                null=True,
                unique=True,
                verbose_name="Номер телефона",
            ),
        ),
    ]


# File: ./src/migrations/0018_image_image_url_alter_image_image.py
# Generated by Django 5.0.6 on 2024-06-08 12:55

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0017_alter_booking_booking_end_time"),
    ]

    operations = [
        migrations.AddField(
            model_name="image",
            name="image_url",
            field=models.CharField(blank=True, max_length=700, null=True),
        ),
        migrations.AlterField(
            model_name="image",
            name="image",
            field=models.ImageField(
                blank=True, null=True, upload_to="images/", verbose_name="Изображение"
            ),
        ),
    ]


# File: ./src/migrations/0007_alter_customer_telegram_id.py
# Generated by Django 5.0.6 on 2024-05-23 20:03

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0006_alter_order_customer_notice"),
    ]

    operations = [
        migrations.AlterField(
            model_name="customer",
            name="telegram_id",
            field=models.CharField(
                default="default-user", max_length=30, verbose_name="ID Телеграм"
            ),
        ),
    ]


# File: ./src/migrations/0023_alter_customer_name.py
# Generated by Django 5.0.6 on 2024-06-09 22:53

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0022_customer_name_alter_customer_username"),
    ]

    operations = [
        migrations.AlterField(
            model_name="customer",
            name="name",
            field=models.CharField(
                blank=True, max_length=250, null=True, verbose_name="Имя пользователя"
            ),
        ),
    ]


# File: ./src/migrations/0005_alter_order_customer_alter_order_customer_notice.py
# Generated by Django 5.0.6 on 2024-05-23 19:12

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0004_alter_customer_telegram_id"),
    ]

    operations = [
        migrations.AlterField(
            model_name="order",
            name="customer",
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                to="src.customer",
                verbose_name="Клиент",
            ),
        ),
        migrations.AlterField(
            model_name="order",
            name="customer_notice",
            field=models.CharField(
                default="0", max_length=120, verbose_name="Коментарий"
            ),
        ),
    ]


# File: ./src/migrations/0014_alter_moderator_login.py
# Generated by Django 5.0.6 on 2024-05-31 19:26

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0013_moderator_alter_organization_main_image"),
    ]

    operations = [
        migrations.AlterField(
            model_name="moderator",
            name="login",
            field=models.CharField(max_length=30, unique=True, verbose_name="Логин"),
        ),
    ]


# File: ./src/migrations/0025_alter_order_services.py
# Generated by Django 5.0.6 on 2024-09-11 03:09

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0024_alter_customer_code"),
    ]

    operations = [
        migrations.AlterField(
            model_name="order",
            name="services",
            field=models.ManyToManyField(to="src.service"),
        ),
    ]


# File: ./src/migrations/0003_alter_order_customer_notice.py
# Generated by Django 5.0.6 on 2024-05-23 13:45

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0002_rename_addidional_info_customer_additional_info_and_more"),
    ]

    operations = [
        migrations.AlterField(
            model_name="order",
            name="customer_notice",
            field=models.CharField(
                blank=True, max_length=120, null=True, verbose_name="Коментарий"
            ),
        ),
    ]


# File: ./src/migrations/0019_remove_customer_user_keyword_customer_code.py
# Generated by Django 5.0.6 on 2024-06-09 21:13

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0018_image_image_url_alter_image_image"),
    ]

    operations = [
        migrations.RemoveField(
            model_name="customer",
            name="user_keyword",
        ),
        migrations.AddField(
            model_name="customer",
            name="code",
            field=models.CharField(
                blank=True, max_length=30, null=True, verbose_name="Код для регистрации"
            ),
        ),
    ]


# File: ./src/migrations/__init__.py


# File: ./src/migrations/0020_customer_is_verified.py
# Generated by Django 5.0.6 on 2024-06-09 21:28

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0019_remove_customer_user_keyword_customer_code"),
    ]

    operations = [
        migrations.AddField(
            model_name="customer",
            name="is_verified",
            field=models.BooleanField(
                default=False, verbose_name="Верифицированный клиент"
            ),
        ),
    ]


# File: ./src/migrations/0016_customer_master_alter_master_code.py
# Generated by Django 5.0.6 on 2024-06-04 12:05

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0015_master_image_url_alter_master_image"),
    ]

    operations = [
        migrations.AddField(
            model_name="customer",
            name="master",
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                to="src.master",
            ),
        ),
        migrations.AlterField(
            model_name="master",
            name="code",
            field=models.CharField(
                blank=True,
                max_length=200,
                null=True,
                verbose_name="Код для регистрации",
            ),
        ),
    ]


# File: ./src/migrations/0010_alter_master_code.py
# Generated by Django 5.0.6 on 2024-05-30 18:33

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0009_master_code"),
    ]

    operations = [
        migrations.AlterField(
            model_name="master",
            name="code",
            field=models.IntegerField(default=17417, verbose_name="Слово пароль"),
        ),
    ]


# File: ./src/migrations/0008_alter_master_telegram_id.py
# Generated by Django 5.0.6 on 2024-05-23 20:04

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0007_alter_customer_telegram_id"),
    ]

    operations = [
        migrations.AlterField(
            model_name="master",
            name="telegram_id",
            field=models.CharField(
                default="web_user", max_length=30, verbose_name="ID Телеграм"
            ),
        ),
    ]


# File: ./src/migrations/0001_initial.py
# Generated by Django 4.2.6 on 2024-05-18 14:56

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):
    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="Customer",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "telegram_id",
                    models.CharField(
                        editable=False, max_length=30, verbose_name="ID Телеграм"
                    ),
                ),
                (
                    "phone",
                    models.CharField(
                        blank=True,
                        max_length=30,
                        null=True,
                        verbose_name="Номер телефона",
                    ),
                ),
                (
                    "username",
                    models.CharField(
                        blank=True,
                        max_length=30,
                        null=True,
                        verbose_name="Имя пользователя",
                    ),
                ),
                (
                    "addidional_info",
                    models.CharField(
                        blank=True,
                        max_length=255,
                        null=True,
                        verbose_name="Дополнительная информация",
                    ),
                ),
            ],
            options={
                "verbose_name": "Клиент",
                "verbose_name_plural": "Клиенты",
            },
        ),
        migrations.CreateModel(
            name="Master",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "telegram_id",
                    models.CharField(
                        default="web_user",
                        editable=False,
                        max_length=30,
                        verbose_name="ID Телеграм",
                    ),
                ),
                ("name", models.CharField(max_length=30, verbose_name="Имя")),
                ("surname", models.CharField(max_length=30, verbose_name="Фамилия")),
                (
                    "image",
                    models.ImageField(upload_to="master", verbose_name="Изображние"),
                ),
                (
                    "gender",
                    models.CharField(
                        blank=True,
                        choices=[("MEN", "Мужчина"), ("WOMEN", "Женщина")],
                        default="MEN",
                        max_length=30,
                        verbose_name="Пол",
                    ),
                ),
                (
                    "is_verified",
                    models.BooleanField(default=False, verbose_name="Верифицирован"),
                ),
            ],
            options={
                "verbose_name": "Мастер",
                "verbose_name_plural": "Мастера",
            },
        ),
        migrations.CreateModel(
            name="OrganizationType",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "title",
                    models.CharField(max_length=255, verbose_name="Типы оргинизаций"),
                ),
            ],
            options={
                "verbose_name": "Тип организации",
                "verbose_name_plural": "Типы организаций",
            },
        ),
        migrations.CreateModel(
            name="Service",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("title", models.CharField(max_length=30, verbose_name="Название")),
                (
                    "short_description",
                    models.CharField(
                        blank=True,
                        max_length=150,
                        null=True,
                        verbose_name="Короткое описание",
                    ),
                ),
                ("price", models.PositiveIntegerField(verbose_name="Стоимость")),
                (
                    "min_time",
                    models.IntegerField(
                        verbose_name="Минимальная длительность процедуры"
                    ),
                ),
                (
                    "master",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE, to="src.master"
                    ),
                ),
            ],
            options={
                "verbose_name": "Услуга",
                "verbose_name_plural": "Услуги",
            },
        ),
        migrations.CreateModel(
            name="Organization",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "telegram_id",
                    models.CharField(
                        editable=False, max_length=30, verbose_name="ID Телеграм"
                    ),
                ),
                ("title", models.CharField(max_length=30, verbose_name="Название")),
                (
                    "main_image",
                    models.ImageField(
                        upload_to="business", verbose_name="Заглавное изображение"
                    ),
                ),
                ("address", models.CharField(max_length=30, verbose_name="Адрес")),
                (
                    "contact_phone",
                    models.CharField(max_length=30, verbose_name="Номер телефона"),
                ),
                ("time_begin", models.TimeField(verbose_name="Начало рабочего дня")),
                ("time_end", models.TimeField(verbose_name="Конец рабочего дня")),
                (
                    "work_schedule",
                    models.CharField(max_length=30, verbose_name="График работы"),
                ),
                (
                    "is_verified",
                    models.BooleanField(default=False, verbose_name="Верифицирован"),
                ),
                (
                    "organization_type",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.PROTECT,
                        to="src.organizationtype",
                    ),
                ),
            ],
            options={
                "verbose_name": "Салон",
                "verbose_name_plural": "Салоны",
            },
        ),
        migrations.CreateModel(
            name="Order",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("begin_date", models.DateField(verbose_name="Дата начала")),
                ("begin_time", models.TimeField(verbose_name="Время начала")),
                (
                    "length_time",
                    models.IntegerField(
                        blank=True,
                        editable=False,
                        null=True,
                        verbose_name="Длительность процедуры",
                    ),
                ),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("new", "Новый"),
                            ("in-progress", "В прогрессе"),
                            ("done", "Закончено"),
                        ],
                        default="new",
                        max_length=20,
                        verbose_name="Статус",
                    ),
                ),
                (
                    "customer_phone",
                    models.CharField(
                        max_length=30, verbose_name="Номер телефона клиента"
                    ),
                ),
                (
                    "customer_name",
                    models.CharField(max_length=60, verbose_name="Имя клиента"),
                ),
                (
                    "customer_notice",
                    models.CharField(
                        default=" ", max_length=120, verbose_name="Коментарий"
                    ),
                ),
                ("payment_id", models.CharField(default=" ", max_length=200)),
                ("payment_link", models.CharField(default=" ", max_length=500)),
                (
                    "customer",
                    models.ForeignKey(
                        blank=True,
                        null=True,
                        on_delete=django.db.models.deletion.PROTECT,
                        to="src.customer",
                        verbose_name="Клиент",
                    ),
                ),
                (
                    "services",
                    models.ManyToManyField(blank=True, null=True, to="src.service"),
                ),
            ],
            options={
                "verbose_name": "Заказ",
                "verbose_name_plural": "Заказы",
            },
        ),
        migrations.AddField(
            model_name="master",
            name="organization",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                to="src.organization",
                verbose_name="Организация",
            ),
        ),
        migrations.CreateModel(
            name="Image",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "image",
                    models.ImageField(upload_to="images/", verbose_name="Изображение"),
                ),
                ("priority", models.IntegerField(default=0, verbose_name="Приоритет")),
                (
                    "organization",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        to="src.organization",
                    ),
                ),
            ],
            options={
                "verbose_name": "Изображение",
                "verbose_name_plural": "Изображения",
            },
        ),
        migrations.CreateModel(
            name="Booking",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("booking_date", models.DateField(verbose_name="Дата бронирования")),
                ("booking_time", models.TimeField(verbose_name="Время бронирования")),
                (
                    "booking_end_time",
                    models.TimeField(
                        editable=False, verbose_name="Длительность процедуры"
                    ),
                ),
                (
                    "master",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE, to="src.master"
                    ),
                ),
            ],
            options={
                "verbose_name": "Бронирование",
                "verbose_name_plural": "Бронирование",
            },
        ),
    ]


# File: ./src/migrations/0021_booking_customer.py
# Generated by Django 5.0.6 on 2024-06-09 22:03

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0020_customer_is_verified"),
    ]

    operations = [
        migrations.AddField(
            model_name="booking",
            name="customer",
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.CASCADE,
                to="src.customer",
            ),
        ),
    ]


# File: ./src/migrations/0015_master_image_url_alter_master_image.py
# Generated by Django 5.0.6 on 2024-06-02 14:19

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0014_alter_moderator_login"),
    ]

    operations = [
        migrations.AddField(
            model_name="master",
            name="image_url",
            field=models.CharField(
                blank=True,
                max_length=255,
                null=True,
                verbose_name="Ссылка на изображение",
            ),
        ),
        migrations.AlterField(
            model_name="master",
            name="image",
            field=models.ImageField(
                blank=True, null=True, upload_to="master", verbose_name="Изображние"
            ),
        ),
    ]


# File: ./src/migrations/0011_alter_master_code.py
# Generated by Django 5.0.6 on 2024-05-30 18:36

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0010_alter_master_code"),
    ]

    operations = [
        migrations.AlterField(
            model_name="master",
            name="code",
            field=models.IntegerField(
                blank=True, null=True, verbose_name="Слово пароль"
            ),
        ),
    ]


# File: ./src/migrations/0009_master_code.py
# Generated by Django 5.0.6 on 2024-05-30 18:33

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0008_alter_master_telegram_id"),
    ]

    operations = [
        migrations.AddField(
            model_name="master",
            name="code",
            field=models.IntegerField(
                default=31011, max_length=255, verbose_name="Слово пароль"
            ),
        ),
    ]


# File: ./src/migrations/0013_moderator_alter_organization_main_image.py
# Generated by Django 5.0.6 on 2024-05-31 19:23

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0012_organization_main_image_url"),
    ]

    operations = [
        migrations.CreateModel(
            name="Moderator",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "telegram_id",
                    models.CharField(
                        default="default-user",
                        max_length=30,
                        verbose_name="ID Телеграм",
                    ),
                ),
                (
                    "login",
                    models.CharField(
                        blank=True,
                        max_length=30,
                        null=True,
                        unique=True,
                        verbose_name="Логин",
                    ),
                ),
                (
                    "code",
                    models.CharField(
                        blank=True, max_length=30, null=True, verbose_name="Код"
                    ),
                ),
            ],
            options={
                "verbose_name": "Модераторы",
            },
        ),
        migrations.AlterField(
            model_name="organization",
            name="main_image",
            field=models.ImageField(
                blank=True,
                null=True,
                upload_to="business",
                verbose_name="Заглавное изображение",
            ),
        ),
    ]


# File: ./src/migrations/0006_alter_order_customer_notice.py
# Generated by Django 5.0.6 on 2024-05-23 19:33

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0005_alter_order_customer_alter_order_customer_notice"),
    ]

    operations = [
        migrations.AlterField(
            model_name="order",
            name="customer_notice",
            field=models.CharField(
                blank=True, max_length=120, null=True, verbose_name="Коментарий"
            ),
        ),
    ]


# File: ./src/migrations/0024_alter_customer_code.py
# Generated by Django 5.0.6 on 2024-06-09 23:06

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0023_alter_customer_name"),
    ]

    operations = [
        migrations.AlterField(
            model_name="customer",
            name="code",
            field=models.CharField(
                blank=True,
                max_length=255,
                null=True,
                verbose_name="Код для регистрации",
            ),
        ),
    ]


# File: ./src/migrations/0004_alter_customer_telegram_id.py
# Generated by Django 5.0.6 on 2024-05-23 13:57

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0003_alter_order_customer_notice"),
    ]

    operations = [
        migrations.AlterField(
            model_name="customer",
            name="telegram_id",
            field=models.CharField(max_length=30, verbose_name="ID Телеграм"),
        ),
    ]


# File: ./src/migrations/0017_alter_booking_booking_end_time.py
# Generated by Django 5.0.6 on 2024-06-07 11:00

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0016_customer_master_alter_master_code"),
    ]

    operations = [
        migrations.AlterField(
            model_name="booking",
            name="booking_end_time",
            field=models.TimeField(verbose_name="Длительность процедуры"),
        ),
    ]


# File: ./src/migrations/0012_organization_main_image_url.py
# Generated by Django 5.0.6 on 2024-05-31 18:30

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("src", "0011_alter_master_code"),
    ]

    operations = [
        migrations.AddField(
            model_name="organization",
            name="main_image_url",
            field=models.CharField(blank=True, max_length=400, null=True),
        ),
    ]


# File: ./src/services/image_services.py
def get_full_url(serializer, model, image_field: str) -> str:
    """
    A function to generate a complete URL for images

    serializer: Any serialzier
    model: Any model
    image_field: name field ImageField
    """
    request = serializer.context.get("request")
    main_image_url = (
        getattr(model, image_field).url if getattr(model, image_field) else ""
    )
    if main_image_url == "":
        return getattr(model, image_field + "_url")
    return request.build_absolute_uri(main_image_url)


# File: ./src/services/__init__.py


# File: ./src/services/order_services.py
from datetime import time
from datetime import datetime, timedelta
from typing import Any, OrderedDict

from django.db import transaction
from django.db.models.query import QuerySet
from django.db.models import Sum

from rest_framework.exceptions import ValidationError
from rest_framework.response import Response

from src.tasks import send_message_telegram_on_master, change_status_order
from src.models import Order, Booking, Service, Customer, Organization


def complete_totals(services: QuerySet["Service"]) -> Any:
    """Complete full time length"""
    return services.aggregate(
        total_time_length=Sum("min_time"), total_price=Sum("price")
    )


def time_to_int(time: time) -> int:
    """Time to int"""
    return int(time.strftime("%H:%M").split(":")[0])


def is_free_time(time: str, available_times: list[str]):
    """Не занятое время"""
    hour = time.split(":")[0]
    all_times = map(lambda x: x.split(":")[0], available_times)

    return {"time": time, "is_free": hour not in all_times}


def is_retroactive_date(date):
    """Дата задним числом"""
    return date < datetime.now().date()


class OrderCreateSrv:
    """
    Create order service
    """

    def __init__(
        self, serializer_validate_data: OrderedDict, serialzier_data: OrderedDict
    ):
        self.serializer_data = serialzier_data
        self.master_id = serializer_validate_data.get("master_id")
        self.service_ids = serializer_validate_data.get("service_ids")  # type: ignore
        self.begin_date = serializer_validate_data.get("begin_date")
        self.begin_time = serializer_validate_data.get("begin_time")
        self.customer_phone = serializer_validate_data.get("customer_phone")
        self.customer_name = serializer_validate_data.get("customer_name")
        self.customer_notice = serializer_validate_data.get("customer_notice")

    def _validate_booking_master(self) -> None:
        bookings = Booking.objects.filter(
            master_id=self.master_id,
            booking_date=self.begin_date,
            booking_time=self.begin_time,
        )
        if bookings:
            raise ValidationError(
                {
                    "success": False,
                    "message": "Время уже забронировано другим пользователем",
                    "data": {},
                },
                code=400,
            )

    def _get_all_services(self) -> None:
        self.serivces = Service.objects.filter(id__in=self.service_ids)
        if not self.serivces:
            raise ValidationError(
                {"message": "Нет таких услуг в системе", "success": False, "data": []},
                code=422,
            )

    def _complete_full_time_length(self) -> None:
        """Complete full time length"""
        sum_total_data = complete_totals(services=self.serivces)
        self.summed_num = sum_total_data["total_time_length"]
        self.summed_time = (
            datetime.combine(self.begin_date, self.begin_time)
            + timedelta(minutes=sum_total_data["total_time_length"])
        ).time()
        self.total_price = sum_total_data["total_price"]

        if not self.summed_time or not self.total_price:
            raise ValidationError(code=422)

    def _create_order(self) -> None:
        """Create order"""
        self.order = Order.objects.create(
            begin_date=self.begin_date,
            begin_time=self.begin_time,
            length_time=self.summed_num,
            customer_phone=self.customer_phone,
            customer_name=self.customer_name,
            customer_notice=self.customer_notice,
        )
        for i in self.service_ids:  # type: ignore
            self.order.services.add(i)
        self.order.save()

    def _create_booking(self):
        """Create booking"""
        self.booking = Booking.objects.create(
            booking_date=self.order.begin_date,
            booking_time=self.begin_time,
            booking_end_time=self.summed_time,
            master_id=self.master_id,
        )

    def _create_customer(self):
        """Создание клиента в БД"""
        self.customer = Customer.objects.filter(phone=self.customer_phone).first()

        if not self.customer:
            self.customer = Customer.objects.create(
                phone=self.customer_phone,
                name=self.customer_name,
                master_id=self.master_id,
            )
        else:
            self.customer.name = self.customer_name
            self.customer.save()
        self.booking.customer = self.customer
        self.booking.save()

    def _send_notification_on_master(self):
        """Отправка сообщания мастеру о брони"""
        send_message_telegram_on_master.delay(
            self.master_id, self.customer_phone, self.begin_date, self.begin_time
        )

    def _send_order_status_check(self):
        """Смена статуса брони или заказа"""
        change_in_progress_time = (
            datetime.combine(self.begin_date, self.begin_time) - datetime.now()
        ).total_seconds()

        change_done_time = (
            datetime.combine(self.begin_date, self.begin_time)
            + timedelta(minutes=30)
            - datetime.now()
        ).total_seconds()

        change_status_order.apply_async(
            (self.order.pk, "in-progress"), countdown=change_in_progress_time
        )
        change_status_order.apply_async(
            (self.order.pk, "done"), countdown=change_done_time
        )

    @transaction.atomic
    def execute(self):
        """Run commands"""
        self._validate_booking_master()
        self._get_all_services()
        self._complete_full_time_length()

        self._create_order()
        self._create_booking()
        self._create_customer()
        self._send_notification_on_master()
        self._send_order_status_check()

        return Response(
            {
                "message": "Заказ успешно создан",
                "success": True,
                "data": self.serializer_data,
                "code": self.customer.code,
            },
            status=201,
        )


class FreeBookingSrv:
    """
    Free booking dates and times
    """

    def __init__(self, serializer_validated_data: OrderedDict) -> None:
        self.date = serializer_validated_data.get("date")
        self.master_id = serializer_validated_data.get("master_id")

    def _get_master_bookings(self) -> None:
        """
        Get all booking on current date
        """
        self.bookings = Booking.objects.filter(
            master_id=self.master_id, booking_date=self.date
        )

    def _generate_organization_times(self):
        self.organization = Organization.objects.filter(master=self.master_id).first()
        start_time = time_to_int(self.organization.time_begin)
        end_time = time_to_int(self.organization.time_end)
        self.times = [f"{i}:00" for i in range(start_time, end_time)]

    def _get_master_available_time(self):
        """
        Get master available time
        """
        self.available_times = set()
        if not self.bookings:
            for i in range(
                time_to_int(self.organization.time_begin),
                time_to_int(datetime.now().time()) + 1,
            ):
                self.available_times.add(f"{i}:00")
        for booking in self.bookings:
            start = time_to_int(booking.booking_time)
            end = time_to_int(booking.booking_end_time)

            if (
                booking.booking_date == datetime.now().date()
                and time_to_int(datetime.now().time()) > start
            ):
                for i in range(
                    time_to_int(booking.master.organization.time_begin),
                    time_to_int(datetime.now().time()) + 1,
                ):
                    self.available_times.add(f"{i}:00")
            else:
                for i in range(start, end + 1):
                    self.available_times.add(f"{i}:00")

    def _generate_all_times(self):
        """
        Generate all times for response
        """
        self.free_times = [
            is_free_time(i, sorted(self.available_times)) for i in self.times
        ]

    def execute(self):
        """
        Run commands
        """
        if is_retroactive_date(self.date):
            self._generate_organization_times()
            self.free_times = [{"time": i, "is_free": False} for i in self.times]
            return Response(
                {
                    "message": "All times has been received",
                    "success": True,
                    "data": self.free_times,
                },
                status=200,
            )

        self._get_master_bookings()
        self._generate_organization_times()
        self._get_master_available_time()
        self._generate_all_times()
        return Response(
            {
                "message": "All times has been received",
                "success": True,
                "data": self.free_times,
            },
            status=200,
        )


# File: ./src/services/payment_srv.py
import hashlib
import uuid
from urllib.parse import urlencode


class PaymentMethod:
    """Платежные методы"""

    PAY = "pay/"  # пополние


class Currency:
    """Валюты"""

    RU = "RUB"


class AAIOBank:
    BASE_URL = "https://aaio.so/merchant/"

    def __init__(self, merchant_id: str, aaio_api_key: str) -> None:
        self.sign = None
        self.amount = None
        self.currency = None
        self.order_id = None
        self.desc = None
        self.lang = None
        self.merchant_id: str = merchant_id
        self.aaio_api_key: str = aaio_api_key

    def _generate_payment_information(self, amount: float):
        self.amount = amount
        self.currency = Currency.RU
        self.order_id = uuid.uuid4()
        self.desc = "Order Payment"
        self.lang = "ru"

    def _generate_signature(self):
        self.sign = ":".join(
            [
                str(self.merchant_id),
                str(self.amount),
                str(self.currency),
                str(self.aaio_api_key),
                str(self.order_id),
            ]
        )

    def create_payment(self, amount: float):
        self._generate_payment_information(amount)
        self._generate_signature()

        if not self.sign:
            raise ValueError("Not sing yet")

        params = {
            "merchant_id": self.merchant_id,
            "amount": self.amount,
            "currency": self.currency,
            "order_id": self.order_id,
            "sign": hashlib.sha256(self.sign.encode("utf-8")).hexdigest(),
            "desc": self.desc,
            "lang": self.lang,
        }

        url_encode = urlencode(params)
        payment_data = {
            "amount": self.amount,
            "url": self.BASE_URL + PaymentMethod.PAY + "?" + url_encode,
            "order_id": self.order_id,
        }

        return payment_data


# File: ./src/services/organization_services.py
from django.db.models import Q

from rest_framework.response import Response

from src.models import OrganizationType, Organization, Service


def get_organization_types() -> Response:
    """
    Getting all organization types for filters on frontend
    """
    organization_types = OrganizationType.objects.filter().values("id", "title")
    return Response(
        {
            "message": "Данные успешно получены",
            "success": True,
            "data": organization_types,
        }
    )


def search_organization(search: str) -> Response:
    """
    Search organization by title and by organization type title
    """
    queryset = Organization.objects.filter(
        Q(title__icontains=search)
        | Q(organization_type__title__contains=search)
        | Q(organization_type__title__exact=search)
    ).values("id", "title")

    return Response(
        {"message": "Запрос успешно выполнен", "success": True, "data": queryset}
    )


def get_services_title() -> Response:
    """
    Get services lise for filters in frontend
    """
    queryset = Service.objects.values("id", "title")

    return Response(
        {"message": "Запрос успешно выполнен", "success": True, "data": queryset}
    )


def get_master_services(master_id: int) -> Response:
    """Get master services"""
    if master_id == 0:
        return Response(
            {"message": "Запрос успешно выполнен", "success": True, "data": []},
            status=200,
        )

    queryset = Service.objects.filter(master=master_id)
    return Response(
        {
            "message": "Запрос успешно выполнен",
            "success": True,
            "data": queryset.values(
                "id",
                "title",
                "short_description",
                "price",
                "min_time",
            ),
        },
        status=200,
    )


# File: ./src/tests/organization_tests.py
# Create your tests here.


# File: ./src/tests/order_tests.py
from datetime import datetime, time
from collections import OrderedDict
from django.core.files.uploadedfile import SimpleUploadedFile

from rest_framework.test import APITestCase

from src.services.order_services import OrderCreateSrv, FreeBookingSrv
from src.models import Master, Service, Organization, OrganizationType


def generate_image():
    return SimpleUploadedFile(
        name="image.png",
        content=open("image.png", "rb").read(),
        content_type="image/png",
    )


class OrderTestCase(APITestCase):
    """
    Order test case
    """

    def setUp(self):
        self.organization_type = OrganizationType.objects.create(
            title="orgnization_type"
        )
        self.organization = Organization.objects.create(
            title="title",
            main_image=generate_image(),
            is_verified=True,
            address="address",
            contact_phone="9999",
            time_begin=datetime.now().time(),
            time_end=datetime.now().time(),
            work_schedule="5/2",
            organization_type_id=self.organization_type.id,
        )
        self.master = Master.objects.create(
            name="test",
            surname="test",
            image=generate_image(),
            organization=self.organization,
        )
        self.service = Service.objects.create(
            master=self.master, title="title", price=10, min_time=30
        )
        self.booking_test_date = datetime(day=10, year=2023, month=12)

    def test_create_order(self):
        data = OrderedDict(
            master_id=self.master.id,
            service_ids=[
                1,
            ],
            begin_date=datetime(day=10, year=2023, month=12),
            begin_time=time(hour=10, minute=30),
            customer_phone="89",
            customer_name="name",
            customer_notice="notice",
        )
        order_create_srv = OrderCreateSrv(
            serialzier_data=data, serializer_validate_data=data
        )
        response = order_create_srv.execute()

        self.master.refresh_from_db()
        self.assertEqual(response.status_code, 201)
        self.assertEqual(self.master.booking_set.all().count(), 1)

    def test_getting_bookings(self):
        data = OrderedDict(master_id=self.master.id, date=self.booking_test_date)
        booking_times = FreeBookingSrv(data)
        response = booking_times.execute()
        self.assertEqual(response.status_code, 200)

    def test_getting_bookings_ok(self):
        service = self.service = Service.objects.create(
            master=self.master, title="title", price=10, min_time=90
        )
        data = OrderedDict(
            master_id=self.master.id,
            service_ids=[
                service.pk,
            ],
            begin_date=self.booking_test_date,
            begin_time=time(hour=10, minute=30),
            customer_phone="89",
            customer_name="name",
            customer_notice="notice",
        )
        order_create_srv = OrderCreateSrv(
            serialzier_data=data, serializer_validate_data=data
        )
        order_create_srv.execute()

        booking_data = OrderedDict(
            master_id=self.master.id, date=datetime(day=11, year=2023, month=12)
        )
        booking_times = FreeBookingSrv(booking_data)
        response = booking_times.execute()
        self.assertEqual(response.status_code, 200)

        # todo Дописать тесты


# File: ./src/tests/__init__.py
from src.tests.order_tests import OrderTestCase

__all__ = "OrderTestCase",


# File: ./src/enums/statuses.py
ESTABLISHMENT_TYPE = (
    ("SALON", "Салон Красоты"),
    ("BEAUTY", "Парикмахерская"),
)
CHOICES_GENDER = (
    ("MEN", "Мужчина"),
    ("WOMEN", "Женщина"),
)

CHOICES_STATUS = (
    ("new", "Новый"),
    ("in-progress", "В прогрессе"),
    ("done", "Закончено"),
)


# File: ./src/serializers/__init__.py


# File: ./src/serializers/image_serializers.py
from rest_framework import serializers
from src.models import Image
from src.services.image_services import get_full_url


class ImageSerializer(serializers.ModelSerializer):
    """
    A serializer for image model
    """

    image = serializers.SerializerMethodField()

    class Meta:
        model = Image
        fields = ("id", "image", "priority")

    def get_image(self, obj):
        return get_full_url(self, obj, "image")


# File: ./src/serializers/order_serializers.py
"""
Order serializers
"""

from rest_framework import serializers


class OrderSerializer(serializers.Serializer):
    """Order create serializer"""

    master_id = serializers.IntegerField()
    service_ids = serializers.ListField(child=serializers.IntegerField())
    begin_date = serializers.DateField()
    begin_time = serializers.TimeField()
    customer_phone = serializers.CharField(max_length=30)
    customer_name = serializers.CharField(
        max_length=60,
    )
    customer_notice = serializers.CharField(
        max_length=120, allow_null=True, required=False, allow_blank=True
    )


class BookingSerializer(serializers.Serializer):
    date = serializers.DateField()
    master_id = serializers.IntegerField()


# File: ./src/serializers/organization_serializers.py
import datetime

from rest_framework import serializers

from src.models import Organization, Master, Service
from src.serializers.image_serializers import ImageSerializer
from src.services.image_services import get_full_url


class MasterServiceSerializer(serializers.ModelSerializer):
    class Meta:
        model = Service
        fields = ("id", "title")


class OrganizationServiceSerializer(serializers.ModelSerializer):
    class Meta:
        model = Service
        fields = (
            "id",
            "title",
            "short_description",
            "price",
            "min_time",
        )


class MasterSerializer(serializers.ModelSerializer):
    services = serializers.SerializerMethodField()
    image = serializers.SerializerMethodField()

    class Meta:
        model = Master
        fields = ("id", "image", "name", "surname", "services")

    def get_services(self, master: Master):
        return MasterServiceSerializer(
            instance=master.service_set.all(), many=True
        ).data[:3]

    def get_image(self, obj):
        return get_full_url(self, obj, "image")


class OrganizationSerializer(serializers.ModelSerializer):
    """Serializer for the organization's list page"""

    main_image = serializers.SerializerMethodField()
    time_begin = serializers.TimeField(format="%H:%M")
    time_end = serializers.TimeField(format="%H:%M")
    is_open = serializers.SerializerMethodField()

    class Meta:
        model = Organization
        fields = (
            "id",
            "title",
            "main_image",
            "time_begin",
            "time_end",
            "address",
            "work_schedule",
            "is_open",
        )

    def get_is_open(self, organization: Organization):
        now_time = datetime.datetime.now().time()
        return organization.time_begin < now_time < organization.time_end

    def get_main_image(self, organization: Organization):
        return get_full_url(self, organization, "main_image")


class OrganizationDetailSerializer(OrganizationSerializer):
    """Serializer for the detailed organization page"""

    gallery = serializers.SerializerMethodField()
    masters = serializers.SerializerMethodField()
    services = serializers.SerializerMethodField()

    class Meta:
        model = Organization
        fields = "__all__"

    def get_gallery(self, organization: Organization):
        gallery_serializer = ImageSerializer(
            instance=organization.image_set.all(), many=True, context=self.context
        )
        return gallery_serializer.data

    def get_masters(self, organization: Organization):
        master_serializer = MasterSerializer(
            instance=organization.master_set.all(), many=True, context=self.context
        )
        return master_serializer.data

    def get_services(self, organization: Organization):
        services = OrganizationServiceSerializer(
            instance=Service.objects.filter(master__organization=organization),
            many=True,
        )
        return services.data


# File: ./config/urls.py
from django.conf import settings
from django.conf.urls.static import static

from django.urls import include, path

from src.admin import content_management_admin
from drf_spectacular.views import (
    SpectacularAPIView,
    SpectacularRedocView,
    SpectacularSwaggerView,
)


urlpatterns = [
    path("admin/", content_management_admin.urls),
    path("api/", include("src.urls")),
    path("bot-api/", include("bot.urls")),
    path("api/schema/", SpectacularAPIView.as_view(), name="schema"),
    path(
        "schema/", SpectacularSwaggerView.as_view(url_name="schema"), name="swagger-ui"
    ),
    path(
        "api/schema/redoc/",
        SpectacularRedocView.as_view(url_name="schema"),
        name="redoc",
    ),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


# File: ./config/asgi.py
"""
ASGI config for FIXMASTER project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")

application = get_asgi_application()


# File: ./config/__init__.py
from config.celery import app as celery_app

__all__ = ("celery_app",)


# File: ./config/celery.py
"""
Celery in project
"""

import os
from celery import Celery
from dotenv import load_dotenv

load_dotenv()

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")

app = Celery("django_app")
app.config_from_object("django.conf:settings", namespace="CELERY")
app.autodiscover_tasks()


# File: ./config/settings.py
import os
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent

LOGGING_DIR = os.path.join(BASE_DIR, "logs")

if not os.path.exists(LOGGING_DIR):
    os.makedirs(LOGGING_DIR)

SECRET_KEY = os.getenv("SECRET_KEY")

DEBUG = True

ALLOWED_HOSTS = ["*"]

ROOT_APPS = ["src", "bot"]
INSTALLED_APPS = [
    "django_celery_beat",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "rest_framework",
    "corsheaders",
    "drf_spectacular",
    "drf_spectacular_sidecar",
    *ROOT_APPS,
]
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "config.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "config.wsgi.application"

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": os.getenv("DB_NAME"),
        "USER": os.getenv("DB_USER"),
        "PASSWORD": os.getenv("DB_PASSWORD"),
        "HOST": os.getenv("DB_HOST"),
        "PORT": os.getenv("DB_PORT"),
    },
}
DATABASES["default"] = {
    "ENGINE": "django.db.backends.sqlite3",
    "NAME": BASE_DIR / "db.sqlite3",
}

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]

LANGUAGE_CODE = "ru"

TIME_ZONE = "Europe/Moscow"

USE_I18N = True

USE_L10N = True

USE_TZ = True

STATIC_URL = "/static/"
STATIC_ROOT = os.path.join(BASE_DIR, "static")
STATIC_DIRS = [os.path.join(BASE_DIR, "static")]

MEDIA_URL = "/media/"
MEDIA_ROOT = os.path.join(BASE_DIR, "media")

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

CORS_ALLOW_ALL_ORIGINS = True

REST_FRAMEWORK = {
    "DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
    "DEFAULT_AUTHENTICATION_CLASSES": [
        # 'rest_framework.authentication.SessionAuthentication',
        "rest_framework.authentication.BasicAuthentication",
    ],
}
DATE_INPUT_FORMATS = ["%m-%d-%Y"]
SPECTACULAR_SETTINGS = {
    "TITLE": "FixMaster API",
    "DESCRIPTION": "Compact booking of master",
    "VERSION": "1.0.0",
    "SERVE_INCLUDE_SCHEMA": False,
    "SWAGGER_UI_DIST": "SIDECAR",
    "SWAGGER_UI_FAVICON_HREF": "SIDECAR",
    "REDOC_DIST": "SIDECAR",
}
# LOGGING = {
#     "version": 1,
#     "disable_existing_loggers": False,
#     "formatters": {
#         "main": {
#             'format': '[%(asctime)s] %(levelname)s %(message)s',
#             "datefmt": "%Y-%m-%d %H:%M:%S",
#             "style": "%",
#         },
#     },
#     "handlers": {
#         "file": {
#             "level": "INFO",
#             "class": "logging.FileHandler",
#             'filename': os.path.join(LOGGING_DIR, 'django.log'),
#             "formatter": "main",
#         },
#     },
#     "loggers": {
#         "django": {
#             "handlers": ["file"],
#             "level": "INFO",
#             "propagate": True,
#         },
#     },
# }

import pickle

import redis

cache = redis.Redis(
    host="localhost",
)


def dict_set(name: str, data: dict):
    cache.set(name, pickle.dumps(data))


def dict_get(name: str) -> dict:
    if value := cache.get(name):
        return pickle.loads(value)


CELERY_BROKER_URL = "redis://localhost:6379"
CELERY_TIMEZONE = "Europe/Moscow"

FIXMASTER_CLIENT_BOT_TOKEN = os.getenv("FIXMASTER_CLIENT_BOT_TOKEN")
FIXMASTER_MASTER_BOT_TOKEN = os.getenv("FIXMASTER_MASTER_BOT_TOKEN")
FIXMASTER_MODERATOR_BOT_TOKEN = os.getenv("FIXMASTER_MODERATOR_BOT_TOKEN")
FIXMASTER_ORGANIZATION_BOT_TOKEN = os.getenv("FIXMASTER_ORGANIZATION_BOT_TOKEN")


# File: ./config/wsgi.py
"""
WSGI config for FIXMASTER project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "confing.settings")

application = get_wsgi_application()


# File: ./bot/urls.py
from django.urls import path
from bot.views import (
    BotMyProfileView,
    BotOrganizationCreateView,
    BotModeratorGetProfileView,
    BotVerifyOrganizationView,
    BotGetOrganizationByTelegramIdView,
    BotGetOrganizationDataByTelegramIdView,
    MasterActionView,
    ServiceActionView,
    MasterVerifyView,
    MasterCustomerView,
    MasterNextSessionView,
    CustomerNextSessionView,
    CustomerVerifyView,
    CheckCustomerView,
)

urlpatterns = [
    path("get-my-profile/", BotMyProfileView.as_view(), name="get-profile"),
    path(
        "organization/create/",
        BotOrganizationCreateView.as_view(),
        name="bot-create-organization",
    ),
    path(
        "organization/verify/<int:organization_id>/",
        BotVerifyOrganizationView.as_view(),
        name="bot-organization-verify",
    ),
    path(
        "organization/get-by-telegram_id/<str:telegram_id>",
        BotGetOrganizationByTelegramIdView.as_view(),
        name="bot-organization-get-by-telegram_id",
    ),
    path(
        "organization-data/get-by-telegram_id/<str:telegram_id>",
        BotGetOrganizationDataByTelegramIdView.as_view(),
        name="bot-organization_data-get-by-telegram_id",
    ),
    path(
        "moderator/", BotModeratorGetProfileView.as_view(), name="get-moderator-profile"
    ),
    path("masters/<int:master_id>", MasterActionView.as_view()),
    path("masters/", MasterActionView.as_view()),
    path("masters/<int:master_id>/services/", ServiceActionView.as_view()),
    path("service/", ServiceActionView.as_view()),
    path("master/verify/", MasterVerifyView.as_view()),
    path("master/<str:telegram_id>/customers/", MasterCustomerView.as_view()),
    path("master/<str:telegram_id>/last-booking/", MasterNextSessionView.as_view()),
    path("customer/verify/", CustomerVerifyView.as_view()),
    path("customer/<str:telegram_id>/last-booking/", CustomerNextSessionView.as_view()),
    path("customer/check/", CheckCustomerView.as_view()),
]


# File: ./bot/webhook_view.py



# File: ./bot/serializers.py
from rest_framework import serializers


class BotOrganizationCreateSerializer(serializers.Serializer):
    telegram_id = serializers.CharField()
    title = serializers.CharField()
    main_image_url = serializers.CharField()
    address = serializers.CharField()
    contact_phone = serializers.CharField()
    time_begin = serializers.CharField()
    time_end = serializers.CharField()
    work_schedule = serializers.CharField()
    organization_type_id = serializers.IntegerField()
    gallery = serializers.ListField(child=serializers.CharField())


class BotModeratorGetProfileSerializer(serializers.Serializer):
    telegram_id = serializers.CharField()
    login = serializers.CharField()
    code = serializers.CharField()


class MasterCreateSerializer(serializers.Serializer):
    name = serializers.CharField()
    surname = serializers.CharField()
    image_url = serializers.CharField()
    organization_id = serializers.IntegerField()


class MasterEditSerializer(serializers.Serializer):
    name = serializers.CharField(required=False)
    surname = serializers.CharField(required=False)
    image_url = serializers.CharField(required=False)
    organization_id = serializers.IntegerField()


class MasterServiceCreateSerializer(serializers.Serializer):
    title = serializers.CharField()
    short_description = serializers.CharField()
    price = serializers.CharField()
    min_time = serializers.CharField()


class MasterServiceEditSerializer(serializers.Serializer):
    title = serializers.CharField(required=False)
    short_description = serializers.CharField(required=False)
    price = serializers.IntegerField(required=False)
    min_time = serializers.CharField(required=False)


class MasterVerifySerializer(serializers.Serializer):
    code = serializers.CharField(max_length=200)
    telegram_id = serializers.CharField(max_length=100)


# File: ./bot/__init__.py
"""(А) - Тема дипломной работы "Cервис удобного бронирования мастеров"
    1. Цели проекта:
        Разработка MVP сервиса для удобного бронирования мастеров в парикмахерских или салонах красоты.
        Разработка удобного формата работы с данными с помощью Telegram-ботов.
        ...
    1. Сервис состоит из 3-х частей:
         - Клиентская часть (Front-End)
         - Серверная часть (Back-End)
         - 4 Telegram-бота

    2. Подробная информация о сервисе:

         1 -  Серверная часть (Back-End):
             1. Стек технологий:
                - Python, Django
                - Redis, Celery
                - PostgresQL
                - Docker, Nginx
             2. Короткое описание:
                - Серверная часть состоит из 3 компонентов: Notification, BotAPI, ClientAPI
                - Notification отвечает за уведомления в ботах
                - BotAPI включает всю API-логику для Telegram-ботов
                - ClientAPI включает всю API-логику для клиентской части сервиса
             3. Ссылка на код: https://github.com/nariman079/fixmaster_backend_django_fastapi

         2 -  Клиентская часть (Front-End):
             1. Стек технологий:
                - Vue3, VueJS
                - Vue Router
             2. Короткое описание:
                - На данном сайте пользователь может выбрать организацию/мастера/услугу и записаться в удобное для него время
                - Возможность выбора множества услуг мастера при бронировании
                - После бронирования мастер может перейти в Telegram-бота для дальнейших действий (см. Бот для клиентов)
             3. Ссылка на код: https://github.com/nariman079/fixmaster_frontent_js_vue
         3 -  4 Telegram-бота:
             1. Стек технологий:
                - Python, PyTelegramBot
                - S3
             2. Боты и их короткие описания:
                (1) Бот для клиентов:
                    - Уведомление о брони за 3 часа/1 час/15 мин
                    - Возможность посмотреть следующую бронь
                    - (Нереализованная фича) Возможность добавлять отзыв о мастере после процедуры
                (2) Бот для организации:
                    - Регистрация организации в системе для отображения на главной странице
                    - Добавление/Изменение/Удаление мастеров или услуг мастера
                    - Получение клиентской базы организации
                (3) Бот для мастеров:
                    - Авторизация мастера
                    - Получение информации о новых бронях, а также клиентах
                    - Просмотр следующей брони
                (4) Бот для модераторов:
                    - Регистрация модератора (после создания модератора в админке)
                    - Верификация созданных организаций
             3. Ссылка на код: https://github.com/nariman079/fixmaster_telegram_bot_pyTelegramBot
(B) Учебные дисциплины, которые мне больше всего понравились:
    - РПМ (разработка програмных модулей)
    - БД (базы данных)
    - ТРиЗБД (технологии разработки и защиты базы данных)
    - СРПО (средства разработки програмного обеспечения)
    - СП - (системное программирование)
(С) Примеры моего кода:
    - https://github.com/nariman079/travel_agency_backend_django
    - https://github.com/nariman079/anonymous_chat_backend_fast_api
    - https://github.com/nariman079/ - GitHub Account
"""

"""
1) Медали:
    - Получил медаль за 1-ое место в Региональном этапе чемпионата «Профессионалы» https://pro.firpo.ru/
2) Красный диплом
"""

"""
Я вижу в стажировке возможность начать свою карьеру в крупной и престижной компании, с перспективой дальнейшего профессионального роста.
Работать в такой компании – это возможность учиться у лучших и стать частью инновационной среды.
Стажировка в Яндексе предоставляет уникальную возможность получить практический опыт работы с реальными проектами и задачами
Яндекс занимается множеством различных проектов, от поисковых систем до облачных сервисов и искусственного интеллекта. Участие в таких проектах может быть не только полезным, но и увлекательным.

"""
"""
Python - 7/10 
Django - 8/10 
FastAPI - 3/10
GraphQL - 5/10
SQL (PostgreSQL, MySQL) - 7/10
GIT - 7/10
VueJS - 4/10
"""


# File: ./bot/tests.py
from django.urls import reverse
from django.core.files.uploadedfile import SimpleUploadedFile
from rest_framework.test import APITestCase

from bot.services import BotOrganizationCreate
from src.models import OrganizationType


class BotTestCase(APITestCase):
    def setUp(self):
        self.organization_type = OrganizationType.objects.create(title="title")

    def test_get_my_profile_api_key_error(self):
        headers = {"Api-Key": "test"}
        params = {
            "phone_number": "",
            "telegram_id": "",
            "user_keyword": "",
            "username": "",
        }
        response = self.client.get(
            reverse("get-profile"), headers=headers, params=params
        )
        self.assertEqual(response.status_code, 400)

    def test_get_profile_api_key_ok(self):
        headers = {"Api-Key": "X20HHA"}
        params = {
            "phone_number": "",
            "telegram_id": "",
            "user_keyword": "",
            "username": "",
        }
        response = self.client.get(
            reverse("get-profile"), headers=headers, params=params
        )
        self.assertEqual(response.status_code, 422)

    def test_create_organization_from_bot(self):
        data = {
            "telegram_id": "11111",
            "title": "title",
            "main_image": SimpleUploadedFile(
                name="test.png",
                content=open("image.png", "rb").read(),
                content_type="image/png",
            ),
            "address": "address",
            "contact_phone": "contact_phone",
            "time_begin": "10:00",
            "time_end": "19:00",
            "work_schedule": "work_schedule",
            "organization_type_id": self.organization_type.id,
        }
        response = BotOrganizationCreate(organization_data=data).execute()

        self.assertEqual(response.status_code, 201)


# File: ./bot/dataclasses_csm.py
from dataclasses import dataclass


@dataclass
class OrganizationData:
    """
    Огранизации
    """

    telegram_id: str
    title: str
    main_image: bytes
    address: str
    contact_phone: str
    time_begin: str
    time_end: str
    work_schedule: str
    organization_type_id: int


# File: ./bot/permissions.py
def api_key_permission(request) -> bool:
    api_key = request.headers.get("Api-Key")
    if api_key and api_key == "test":
        return True
    else:
        return False


# File: ./bot/views.py
from drf_spectacular.types import OpenApiTypes
from drf_spectacular.utils import OpenApiParameter, OpenApiRequest, extend_schema
from rest_framework.response import Response
from rest_framework.views import APIView

from bot.permissions import api_key_permission
from bot.services import (
    GetProfile,
    BotOrganizationCreate,
    BotModeratorGetProfile,
    BotVerifyOrganization,
    BotGetOrganizationByTelegramId,
    BotGetOrganizationDataByTelegramId,
    MasterDeleteSrv,
    MasterCreateSrv,
    MasterEditSrv,
    MasterServiceCreateSrv,
    MasterServiceDeleteSrv,
    MasterServiceDetailSrv,
    MasterServiceListSrv,
    MasterServiceEditSrv,
    MasterVerifySrv,
    MasterCustomers,
    MasterNextSessionSrv,
    CustomerNextSessionSrv,
    CustomerVerifySrv,
    CheckCustomerSrv,
)
from bot.serializers import (
    BotOrganizationCreateSerializer,
    BotModeratorGetProfileSerializer,
    MasterCreateSerializer,
    MasterEditSerializer,
    MasterServiceCreateSerializer,
    MasterVerifySerializer,
)


class BotMyProfileView(APIView):
    @extend_schema(
        description="Search organization",
        methods=[
            "GET",
        ],
        parameters=[
            OpenApiParameter(
                name="Api-Key",
                type=OpenApiTypes.STR,
                location=OpenApiParameter.HEADER,
                description="Api key for telegram",
            ),
            OpenApiParameter(
                name="phone_number",
                type=OpenApiTypes.STR,
            ),
            OpenApiParameter(name="telegram_id", type=OpenApiTypes.STR),
            OpenApiParameter(name="username", type=OpenApiTypes.STR),
            OpenApiParameter(name="user_keyword", type=OpenApiTypes.STR),
        ],
    )
    def get(self, *args, **kwargs) -> Response:
        """Получение профиля клиента"""
        if api_key_permission(request=self.request):
            user_params = self.request.query_params

            get_profile = GetProfile(data=user_params)
            return get_profile.execute()

        return Response(
            {
                "message": "Неизвествная ошибка\nОбратитесь к администратору @nariman079i",
                "success": False,
                "data": [],
            },
            status=422,
        )


class BotOrganizationCreateView(APIView):
    @extend_schema(
        description="Search organization",
        methods=[
            "POST",
        ],
        parameters=[
            OpenApiParameter(
                name="Api-Key",
                type=OpenApiTypes.STR,
                location=OpenApiParameter.HEADER,
                description="Api key for telegram",
            ),
            OpenApiParameter(
                name="title",
                type=OpenApiTypes.STR,
            ),
            OpenApiParameter(name="telegram_id", type=OpenApiTypes.STR),
            OpenApiParameter(name="main_image", type=OpenApiTypes.BINARY),
            OpenApiParameter(name="time_begin", type=OpenApiTypes.TIME),
            OpenApiParameter(name="time_end", type=OpenApiTypes.TIME),
            OpenApiParameter(name="address", type=OpenApiTypes.STR),
            OpenApiParameter(name="work_schedule", type=OpenApiTypes.STR),
            OpenApiParameter(name="organization_type", type=OpenApiTypes.STR),
            OpenApiParameter(name="contact_phone", type=OpenApiTypes.STR),
        ],
    )
    def post(self, request, *args, **kwargs) -> Response:
        """Создание организации"""
        if api_key_permission(request=self.request):
            organization_data = BotOrganizationCreateSerializer(data=self.request.data)
            organization_data.is_valid(raise_exception=True)
            create_organization = BotOrganizationCreate(
                organization_data=organization_data.validated_data
            )
            return create_organization.execute()

        return Response(
            {
                "message": "Неизвествная ошибка\nОбратитесь к администратору @nariman079i",
                "success": False,
                "data": ["Неверный API-KEY"],
            },
            status=422,
        )


class BotModeratorGetProfileView(APIView):
    def post(self, request, *args, **kwargs) -> Response:
        """Создание организации"""
        if api_key_permission(request=self.request):
            moderator_data = BotModeratorGetProfileSerializer(data=self.request.data)
            moderator_data.is_valid(raise_exception=True)
            moderator_get_profile = BotModeratorGetProfile(
                moderator_data=moderator_data.validated_data
            )
            return moderator_get_profile.execute()

        return Response(
            {
                "message": "Неизвествная ошибка\nОбратитесь к администратору @nariman079i",
                "success": False,
                "data": ["Неверный API-KEY"],
            },
            status=422,
        )


class BotVerifyOrganizationView(APIView):
    def post(self, request, *args, **kwargs):
        if api_key_permission(request=self.request):
            verify_organization_data = dict(
                organization_id=kwargs.get("organization_id"),
                is_verify=self.request.data.get("is_verify"),
            )
            verify_organization = BotVerifyOrganization(
                verify_organization_data=verify_organization_data
            )
            return verify_organization.execute()

        return Response(
            {
                "message": "Неизвествная ошибка\nОбратитесь к администратору @nariman079i",
                "success": False,
                "data": ["Неверный API-KEY"],
            },
            status=422,
        )


class BotGetOrganizationByTelegramIdView(APIView):
    def get(self, *args, **kwargs):
        if api_key_permission(request=self.request):
            organization_data = dict(telegram_id=kwargs.get("telegram_id"))

            get_organization_by_telegram_id = BotGetOrganizationByTelegramId(
                organization_data=organization_data
            )
            return get_organization_by_telegram_id.execute()

        return Response(
            {
                "message": "Неизвествная ошибка\nОбратитесь к администратору @nariman079i",
                "success": False,
                "data": ["Неверный API-KEY"],
            },
            status=422,
        )


class BotGetOrganizationDataByTelegramIdView(APIView):
    def get(self, *args, **kwargs):
        if api_key_permission(request=self.request):
            organization_data = dict(telegram_id=kwargs.get("telegram_id"))
            get_organization_by_telegram_id = BotGetOrganizationDataByTelegramId(
                organization_data=organization_data
            )
            return get_organization_by_telegram_id.execute()

        return Response(
            {
                "message": "Неизвествная ошибка\nОбратитесь к администратору @nariman079i",
                "success": False,
                "data": ["Неверный API-KEY"],
            },
            status=422,
        )


class MasterActionView(APIView):
    def post(self, request, *args, **kwargs):
        if api_key_permission(request=self.request):
            serializer = MasterCreateSerializer(data=self.request.data)
            serializer.is_valid(raise_exception=True)
            create_master = MasterCreateSrv(master_data=serializer.validated_data)
            return create_master.execute()

        return Response(
            {
                "message": "Неизвествная ошибка\nОбратитесь к администратору @nariman079i",
                "success": False,
                "data": ["Неверный API-KEY"],
            },
            status=422,
        )

    def patch(self, request, *args, **kwargs):
        if api_key_permission(request=self.request):
            serializer = MasterEditSerializer(data=self.request.data)
            serializer.is_valid(raise_exception=True)
            create_master = MasterEditSrv(
                master_data=serializer.validated_data, master_id=kwargs.get("master_id")
            )
            return create_master.execute()

        return Response(
            {
                "message": "Неизвествная ошибка\nОбратитесь к администратору @nariman079i",
                "success": False,
                "data": ["Неверный API-KEY"],
            },
            status=422,
        )

    def delete(self, request, *args, **kwargs):
        if api_key_permission(request=self.request):
            master_id = kwargs.get("master_id")
            delete_master = MasterDeleteSrv(master_id=master_id)
            return delete_master.execute()

        return Response(
            {
                "message": "Неизвествная ошибка\nОбратитесь к администратору @nariman079i",
                "success": False,
                "data": ["Неверный API-KEY"],
            },
            status=422,
        )


class ServiceActionView(APIView):
    def get(self, request, *args, **kwargs):
        if api_key_permission(self.request):
            service_id = self.request.query_params.get("service_id")
            master_id = kwargs.get("master_id")
            if service_id:
                master_service_detail = MasterServiceDetailSrv(service_id=service_id)
                return master_service_detail.execute()
            else:
                master_service_list = MasterServiceListSrv(master_id=master_id)
                return master_service_list.execute()
        return Response({"message": "Api-Key error", "success": False, "data": []})

    def post(self, request, *args, **kwargs):
        if api_key_permission(self.request):
            master_id = kwargs.get("master_id", None)
            serializer = MasterServiceCreateSerializer(data=self.request.data)
            serializer.is_valid(raise_exception=True)
            master_service_create = MasterServiceCreateSrv(
                master_id=master_id, service_data=serializer.validated_data
            )
            return master_service_create.execute()
        return Response({"message": "Api-Key error", "success": False, "data": []})

    def patch(self, request, *args, **kwargs):
        if api_key_permission(self.request):
            service_id = self.request.query_params.get("service_id", None)
            master_service_edit = MasterServiceEditSrv(
                service_id=service_id, service_data=self.request.data
            )
            return master_service_edit.execute()
        return Response({"message": "Api-Key error", "success": False, "data": []})

    def delete(self, request, *args, **kwargs):
        if api_key_permission(self.request):
            service_id = self.request.query_params.get("service_id", None)
            if service_id:
                master_service_delete = MasterServiceDeleteSrv(
                    service_id=service_id,
                )
            return master_service_delete.execute()
        return Response({"message": "Api-Key error", "success": False, "data": []})


class MasterVerifyView(APIView):
    @extend_schema(
        description="Verfy master",
        methods=[
            "POST",
        ],
        request=[OpenApiRequest()],
    )
    def post(self, request, *args, **kwargs):
        serializer = MasterVerifySerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        if api_key_permission(self.request):
            master_verify = MasterVerifySrv(**serializer.validated_data)
            return master_verify.execute()
        return Response({"message": "Api-Key error", "success": False, "data": []}, 401)


class MasterCustomerView(APIView):
    def get(self, request, *args, **kwargs):
        telegram_id = self.kwargs.get("telegram_id")

        if api_key_permission(self.request):
            master_customers = MasterCustomers(
                serializer_data={"telegram_id": telegram_id}
            )
            return master_customers.execute()
        return Response({"message": "Api-Key error", "success": False, "data": []}, 401)


class MasterNextSessionView(APIView):
    def get(self, request, *args, **kwargs):
        telegram_id = self.kwargs.get("telegram_id")

        if api_key_permission(self.request):
            master_next_session = MasterNextSessionSrv(
                serializer_data={"telegram_id": telegram_id}
            )
            return master_next_session.execute()
        return Response({"message": "Api-Key error", "success": False, "data": []}, 401)


class CustomerNextSessionView(APIView):
    def get(self, request, *args, **kwargs):
        if api_key_permission(self.request):
            customer_next_session = CustomerNextSessionSrv(serializer_data=self.kwargs)
            return customer_next_session.execute()
        return Response({"message": "Api-Key error", "success": False, "data": []}, 401)


class CustomerVerifyView(APIView):
    def get(self, request, *args, **kwargs):
        if api_key_permission(self.request):
            customer_next_session = CustomerVerifySrv(serializer_data=self.request.data)
            return customer_next_session.execute()
        return Response({"message": "Api-Key error", "success": False, "data": []}, 401)


class CheckCustomerView(APIView):
    def post(self, request, *args, **kwargs):
        customer_next_session = CheckCustomerSrv(
            serializer_data=self.request.query_params
        )
        return customer_next_session.execute()


# File: ./bot/config.py
from django.conf import settings
from telebot import TeleBot


client_bot = TeleBot(settings.FIXMASTER_CLIENT_BOT_TOKEN)
master_bot = TeleBot(settings.FIXMASTER_MASTER_BOT_TOKEN)
organization_bot = TeleBot(settings.FIXMASTER_ORGANIZATION_BOT_TOKEN)
moderator_bot = TeleBot(settings.FIXMASTER_MODERATOR_BOT_TOKEN)
print(
    settings.FIXMASTER_MODERATOR_BOT_TOKEN,
    settings.FIXMASTER_ORGANIZATION_BOT_TOKEN,
    settings.FIXMASTER_MASTER_BOT_TOKEN,
    settings.FIXMASTER_CLIENT_BOT_TOKEN,
)


# File: ./bot/services.py
from datetime import datetime

from django.db.models import F
from django.db.transaction import atomic
from config.settings import dict_get, cache
from rest_framework.exceptions import ValidationError
from rest_framework.response import Response

from src.serializers.organization_serializers import OrganizationDetailSerializer
from src.models import Customer, Organization, Master, Moderator, Service, Image
from src.tasks import (
    send_message_on_moderator_about_organization,
    send_message_about_verify_master,
    send_is_verified_organization,
    send_message_about_verify_customer,
)


def check_organization_exist(contact_phone) -> Response:
    """Проверка существования организации в БД"""
    organization = Organization.objects.filter(contact_phone=contact_phone).first()
    if organization:
        raise ValidationError(
            {
                "message": "Такая организация уже есть в системе",
                "success": False,
                "data": [],
            },
            code=400,
        )
    return Response(
        {"message": "Такой организации нет в системе", "success": True, "data": []},
        status=200,
    )


def next_session(start_date, start_time):
    start_date_time_str = f"{start_date} {start_time}"
    start_date_time = datetime.strptime(start_date_time_str, "%Y-%m-%d %H:%M:%S")

    current_date_time = datetime.now()

    result_text = "Следующая процедура через\n"

    time_difference = start_date_time - current_date_time

    total_seconds = int(time_difference.total_seconds())
    days, seconds = divmod(total_seconds, 86400)
    hours, seconds = divmod(seconds, 3600)
    minutes = seconds // 60

    months = days // 30
    days = days % 30

    if months > 0:
        result_text += f" {months} месяцев,"
    if days > 0:
        result_text += f" {days} дней,"
    if hours > 0:
        result_text += f" {hours} часов,"

    output = f"{result_text} {minutes} минут."

    return output


class GetProfile:
    def __init__(self, data: dict):
        try:
            self.phone_number = data["phone_number"]
            self.username = data["username"]
            self.telegram_id = data["telegram_id"]
            self.user_keyword = data["user_keyword"]
        except Exception as error:
            raise ValidationError(
                {
                    "message": "Неизвествная ошибка\nОбратитесь к администратору @nariman079i",
                    "success": False,
                    "data": "\n".join(error.args),
                },
                code=422,
            )

    def _get_customer_from_db(self) -> None:
        """
        Получение клиента из базы данных
        """
        self.customer = Customer.objects.filter(phone=self.phone_number).first()
        if not self.customer:
            raise ValidationError({"message": "Такого клиента нет в системе"})

    def _check_user_keyword(self):
        """Проверка ключегово слова"""
        if self.customer.user_keyword != self.user_keyword:
            raise ValidationError(
                {
                    "message": "Вы неправильно указали слово пароля",
                    "success": False,
                    "data": [],
                },
                code=400,
            )

    def _fill_telegram_user_data(self) -> None:
        """
        Заполнение данных
        """
        self.customer.username = self.username
        self.customer.telegram_id = self.telegram_id
        self.customer.save()

    def execute(self):
        self._get_customer_from_db()
        self._check_user_keyword()
        self._fill_telegram_user_data()

        return Response(
            {
                "message": "Вы успешно авторизовались\nВы будете получать уведомления о брони",
                "success": True,
            }
        )


class BotOrganizationCreate:
    """Создание организации"""

    def __init__(self, organization_data: dict):
        try:
            self.organization = organization_data
            self.gallery = self.organization.pop("gallery")
        except Exception:
            raise ValidationError(
                {
                    "message": "Неизвествная ошибка\nОбратитесь к администратору @nariman079i\n",
                    "success": False,
                    "data": {},
                },
                code=422,
            )

    def _create_organization(self):
        try:
            self.organization_obj: Organization = Organization.objects.create(
                **self.organization
            )

        except Exception as error:
            raise ValidationError(
                {
                    "message": "Неизвестная ошибка\nОбратитесь к администратору @nariman079i\n",
                    "status": False,
                    "data": error.args,
                },
                code=422,
            )

    def _create_gallery(self):
        if self.gallery:
            for image_url in self.gallery:
                Image.objects.create(
                    organization=self.organization_obj, image_url=image_url
                )

    def _send_notification(self):
        send_message_on_moderator_about_organization.delay(self.organization_obj.pk)

    @atomic()
    def execute(self):
        self._create_organization()
        self._send_notification()
        self._create_gallery()
        return Response(
            {
                "message": "Вы успешно авторизовались\nВы будете получать уведомления о брони",
                "success": True,
                "data": self.organization,
            },
            status=201,
        )


class BotMasterGetProfile:
    """Создание организации"""

    def __init__(self, master_data: dict):
        try:
            self.telegram_id = master_data["telegram_id"]
            self.code = master_data["code"]
            self.name = master_data["name"]

        except Exception:
            raise ValidationError(
                {
                    "message": "Неизвествная ошибка\nОбратитесь к администратору @nariman079i\n",
                    "success": False,
                    "data": {},
                },
                code=422,
            )

    def _get_master(self):
        try:
            master = Master.objects.filter(name=self.name).first()
            if not (master and master.code == self.code):
                raise ValidationError()
            master.telegram_id = self.telegram_id

        except Exception as error:
            raise ValidationError(
                {
                    "message": "Неизвестная ошибка\nОбратитесь к администратору @nariman079i\n",
                    "status": False,
                    "data": error.args,
                },
                code=422,
            )

    def execute(self):
        self._get_master()
        # self._send_notification()
        return Response(
            {
                "message": "Вы успешно авторизовались\nВы будете получать уведомления о брони",
                "success": True,
                "data": self.organization,
            },
            status=201,
        )


class BotModeratorGetProfile:
    """Создание организации"""

    def __init__(self, moderator_data: dict):
        try:
            self.telegram_id = moderator_data["telegram_id"]
            self.code = moderator_data["code"]
            self.login = moderator_data["login"]

        except Exception:
            raise ValidationError(
                {
                    "message": "Неизвествная ошибка\nОбратитесь к администратору @nariman079i\n",
                    "success": False,
                    "code": 422,
                    "data": {},
                }
            )

    def _get_moderator(self):
        """Получение модератора"""
        moderator = Moderator.objects.filter(login=self.login).first()
        if moderator.telegram_id == self.telegram_id:
            raise ValidationError(
                {
                    "message": "Вы уже зарегистрированы в системе",
                    "success": True,
                    "code": 440,
                    "data": [],
                }
            )
        if not moderator:
            raise ValidationError(
                {
                    "message": "Модератор с таком логином не зарегистрирован",
                    "success": False,
                    "code": 404,
                    "data": [],
                }
            )
        if not (moderator and str(moderator.code).strip() == str(self.code).strip()):
            raise ValidationError(
                {
                    "message": "Вы неправильно ввели код\nПопробуйте еще раз",
                    "status": False,
                    "code": 400,
                    "data": [],
                }
            )

        moderator.telegram_id = self.telegram_id
        moderator.save()

    def execute(self):
        self._get_moderator()

        return Response(
            {
                "message": "Вы успешно авторизовались\nВы будете получать заявки на верификацию организаций",
                "success": True,
                "code": 201,
                "data": [],
            },
            status=201,
        )


class BotVerifyOrganization:
    def __init__(self, verify_organization_data: dict):
        self.organization_id = verify_organization_data["organization_id"]
        self.is_verify = verify_organization_data["is_verify"]

    def get_organization(self):
        self.organization = Organization.objects.filter(pk=self.organization_id).first()

    def check_verify(self):
        self.organization.is_verified = self.is_verify
        self.organization.save()

    def send_notification(self):
        send_is_verified_organization.delay(self.organization.id, self.is_verify)

    def execute(self):
        self.get_organization()
        self.check_verify()
        self.send_notification()
        return Response({"message": ""})


class BotGetOrganizationByTelegramId:
    def __init__(self, organization_data: dict):
        self.telegram_id = organization_data["telegram_id"]
        print(dict_get(self.telegram_id), "TEST")

    def get_organization(self):
        self.organization = Organization.objects.filter(
            telegram_id=self.telegram_id
        ).first()

    def check_organization(self):
        if self.organization:
            raise ValidationError(
                {
                    "message": "Вы уже есть в системе",
                    "success": False,
                    "data": [],
                    "code": 400,
                }
            )

    def execute(self):
        self.get_organization()
        self.check_organization()
        return Response(
            {"message": "Такого аккаунта нет в системе", "success": True, "data": []},
            status=200,
        )


class BotGetOrganizationDataByTelegramId:
    def __init__(self, organization_data: dict):
        self.telegram_id = organization_data["telegram_id"]

    def get_organization(self):
        self.organization = Organization.objects.filter(
            telegram_id=self.telegram_id
        ).first()

    def execute(self):
        self.get_organization()

        return Response(
            {
                "message": "Данные успешно получены",
                "success": True,
                "data": OrganizationDetailSerializer(instance=self.organization).data,
            },
            status=200,
        )


class MasterDeleteSrv:
    def __init__(self, master_id: int):
        self.master_id = master_id

    def get_master(self):
        self.master = Master.objects.filter(pk=self.master_id)

    def delete_master(self):
        if self.master:
            cache.delete(str(self.master.first().organization.telegram_id))
            self.master.delete()

    def execute(self):
        self.get_master()
        self.delete_master()
        return Response(status=204)


class MasterCreateSrv:
    def __init__(self, master_data: dict):
        self.master_data = master_data

    def create_master(self):
        try:
            self.master = Master.objects.create(**self.master_data)
        except:
            raise ValidationError(
                {
                    "message": "Не удалось создать мастера",
                    "code": 422,
                    "success": False,
                    "data": [],
                }
            )

    def execute(self):
        self.create_master()

        return Response(
            {
                "message": "Мастер успешно создан",
                "success": True,
                "data": self.master.code,
            },
            status=201,
        )


class MasterEditSrv:
    def __init__(self, master_id: int, master_data: dict):
        self.master_data = master_data
        self.master_id = master_id

    def get_master(self):
        self.master = Master.objects.filter(pk=self.master_id)

    def update_master(self):
        if self.master:
            self.master.update(**self.master_data)

    def execute(self):
        self.get_master()
        self.update_master()
        return Response(
            {"message": "Мастер изменен", "success": True, "data": []}, status=200
        )


class MasterServiceListSrv:
    def __init__(self, *args, **kwargs):
        self.master_id = kwargs.get("master_id")

    def get_master_services(self):
        self.master = Master.objects.filter(pk=self.master_id).first()
        self.master_services = self.master.service_set.values(
            "id", "title", "short_description", "price", "min_time", "master_id"
        )

    def execute(self):
        self.get_master_services()
        return Response(
            {
                "message": "Запрос прошел успешно",
                "success": True,
                "data": self.master_services,
            },
            status=200,
        )


class MasterServiceCreateSrv:
    def __init__(self, *args, **kwargs):
        self.master_id = kwargs.get("master_id")
        self.service_data = kwargs.get("service_data")

    def get_master(self):
        self.master = Master.objects.filter(pk=self.master_id).first()
        if not self.master:
            raise ValidationError(
                {"message": "Нет такого мастера", "success": False, "data": []}
            )

    def create_service(self):
        self.master.service_set.create(**self.service_data)

    def execute(self):
        self.get_master()
        self.create_service()
        return Response(
            {"message": "Запрос прошел успешно", "success": True, "data": {}},
            status=201,
        )


class MasterServiceEditSrv:
    def __init__(self, *args, **kwargs):
        self.service_id = kwargs.get("service_id")
        self.service_data = kwargs.get("service_data")

    def get_and_update_service(self):
        self.service = Service.objects.filter(pk=self.service_id)
        self.service.update(**self.service_data)

    def execute(self):
        self.get_and_update_service()
        return Response(
            {"message": "Запрос прошел успешно", "success": True, "data": {}}, 200
        )


class MasterServiceDeleteSrv:
    def __init__(self, *args, **kwargs):
        self.service_id = kwargs.get("service_id")

    def get_and_delete_service(self):
        self.service = Service.objects.filter(pk=self.service_id)
        self.service.delete()

    def execute(self):
        self.get_and_delete_service()
        return Response(
            {"message": "Запрос прошел успешно", "success": True, "data": {}},
            status=204,
        )


class MasterServiceDetailSrv:
    def __init__(self, *args, **kwargs):
        self.service_id = kwargs.get("service_id")

    def get_master_service_detail(self):
        self.services = Service.objects.filter(pk=self.service_id)
        if not self.services:
            raise ValidationError(
                {"message": "Такой услуги нет в системе", "success": False, "data": {}}
            )
        self.service = self.services.values(
            "id", "title", "short_description", "price", "min_time", "master_id"
        ).first()

    def execute(self):
        self.get_master_service_detail()
        return Response(
            {"message": "Запрос прошел успешно", "success": True, "data": self.service}
        )


class CustomerListSrv:
    def __init__(self, organization_telegram_id: int):
        self.organization_telegram_id = organization_telegram_id

    def get_organization_customers(self):
        self.customers = Customer.objects.filter(
            organizatoin__telegram_id=self.organization_telegram_id
        )

    def execute(self):
        self.get_organization_customers()
        return Response({"message": "Запрос прощел успешно"})


class MasterVerifySrv:
    def __init__(self, code: str, telegram_id: str):
        self.code = code
        self.telegram_id = telegram_id

    def get_master_by_code(self):
        self.master = Master.objects.filter(code=self.code).first()
        print(self.master)

    def check_master(self):
        if self.master:
            if self.master.is_verified:
                raise ValidationError(
                    {
                        "message": "Такой пользователь уже есть в системе",
                        "data": [],
                        "success": True,
                    }
                )
            self.master.telegram_id = self.telegram_id
            self.master.is_verified = True
            self.master.save()
        else:
            raise ValidationError(
                {
                    "message": "Такого пользователя нет в системе\nПопробуйте еще раз",
                    "data": [],
                    "success": True,
                }
            )

    def send_notification(self):
        if self.master:
            send_message_about_verify_master.delay(self.master.id)

    def execute(self):
        self.get_master_by_code()
        self.check_master()
        self.send_notification()
        return Response(
            {"message": "Вы авторизованы", "success": True, "data": []}, status=200
        )


class MasterCustomers:
    def __init__(self, serializer_data: dict):
        self.telegram_id = serializer_data.get("telegram_id")

    def get_master(self):
        self.master = Master.objects.filter(telegram_id=self.telegram_id).first()
        print(self.master)
        if not self.master:
            raise ValidationError(
                {
                    "message": "Такого мастера нет в системе",
                    "success": False,
                    "data": [],
                }
            )

    def get_master_clients(self):
        self.customers = self.master.customer_set.all().values("id", "username")
        print(self.customers)

    def execute(self):
        self.get_master()
        self.get_master_clients()
        return Response(
            {
                "message": "Список клиентов получен",
                "success": True,
                "data": self.customers,
            }
        )


class MasterNextSessionSrv:
    def __init__(self, serializer_data: dict):
        self.telegram_id = serializer_data.get("telegram_id")

    def get_master(self):
        self.master = Master.objects.filter(telegram_id=self.telegram_id).first()

        if not self.master:
            raise ValidationError(
                {
                    "message": "Такого мастера нет в системе",
                    "success": False,
                    "data": [],
                }
            )

    def get_master_bookings(self):
        self.booking = (
            (
                self.master.booking_set.filter(
                    booking_date__gte=datetime.now().date(),
                    booking_time__gte=datetime.now().time(),
                )
                .order_by("booking_date")
                .order_by("booking_time")
            )
            .annotate(start_time=F("booking_time"), start_date=F("booking_date"))
            .values("start_time", "start_date")
            .first()
        )

    def complete_time(self):
        self.next_time = next_session(**self.booking)

    def execute(self):
        self.get_master()
        self.get_master_bookings()
        if not self.booking:
            return Response(
                {"message": "У вас нет броней", "success": True, "data": []}
            )

        self.complete_time()

        return Response({"message": self.next_time, "success": True, "data": []})


class CustomerNextSessionSrv:
    def __init__(self, serializer_data: dict):
        self.telegram_id = serializer_data.get("telegram_id")

    def get_client(self):
        self.customer = Customer.objects.filter(telegram_id=self.telegram_id).first()
        print(self.customer)
        if not self.customer:
            raise ValidationError(
                {
                    "message": "Такого клиента нет в системе",
                    "success": False,
                    "data": [],
                }
            )

    def get_customer_bookings(self):
        self.booking = (
            (
                self.customer.master.booking_set.filter(
                    booking_date__gte=datetime.now().date(),
                    booking_time__gte=datetime.now().time(),
                )
                .order_by("booking_date")
                .order_by("booking_time")
            )
            .annotate(start_time=F("booking_time"), start_date=F("booking_date"))
            .values("start_time", "start_date")
            .first()
        )

    def complete_time(self):
        self.next_time = next_session(**self.booking)

    def execute(self):
        self.get_client()
        self.get_customer_bookings()
        if not self.booking:
            return Response(
                {"message": "У вас нет броней", "success": True, "data": []}
            )

        self.complete_time()

        return Response({"message": self.next_time, "success": True, "data": []})


class CustomerVerifySrv:
    def __init__(self, serializer_data: dict):
        self.code = serializer_data.get("code")
        self.telegram_id = serializer_data.get("telegram_id")
        self.username = serializer_data.get("username")

    def get_customer_by_code(self):
        self.customer = Customer.objects.filter(code=self.code).first()

    def verify_customer(self):
        if self.customer:
            if self.customer.is_verified:
                raise ValidationError(
                    {
                        "message": "Такой пользователь уже есть в системе",
                        "data": [],
                        "success": True,
                    }
                )
            self.customer.telegram_id = self.telegram_id
            self.customer.is_verified = True
            self.customer.username = self.username
            self.customer.save()
        else:
            raise ValidationError(
                {
                    "message": "Такого пользователя нет в системе\nПопробуйте еще раз",
                    "data": [],
                    "success": True,
                }
            )

    def send_notification(self):
        if self.customer:
            send_message_about_verify_customer.delay(
                self.customer.master.telegram_id, self.telegram_id
            )

    def execute(self):
        self.get_customer_by_code()
        self.verify_customer()
        self.send_notification()
        return Response(
            {"message": "Вы авторизованы", "success": True, "data": []}, status=200
        )


class CheckCustomerSrv:
    def __init__(self, serializer_data: dict):
        self.telegram_id = serializer_data.get("telegram_id")

    def get_customer_by_code(self):
        self.customer = (
            Customer.objects.filter(telegram_id=self.telegram_id)
            .values("telegram_id", "name", "phone")
            .first()
        )

    def execute(self):
        self.get_customer_by_code()

        if self.customer:
            return Response(
                {"data": self.customer},
                status=200,
            )

        else:
            return Response(status=404)


# File: ./nginx/default.template
upstream backend {
    server localhost:8000;
}
upstream frontend {
    server localhost:3030;
}
server {
    listen 443 ssl;
    server_name ${HOST};
    client_max_body_size 10M;
    ssl_certificate /etc/letsencrypt/live/${HOST}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${HOST}/privkey.pem;

    root /home/www;
    location = /favicon.ico {
        alias /home/www/favicon.ico;
    }
     location / {
        index index.html;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;


        location /api/ {
            proxy_pass http://backend/api/;
        }
        location /bot-api/ {
            proxy_pass http://backend/bot-api/;
        }
        location /admin/ {
            proxy_pass http://backend/admin/;
        }
    }


    location /static/ {
        alias /app/static/;
    }
    location /media/ {
        alias /app/media/;
    }
}



# File: ./customer_main.py
from telebot.types import Message
from telebot import TeleBot

from config.settings import CLIENT_BOT_TOKEN
from customer_bot.services import CustomerLastBookingSrv, CustomerAuthorizationSrv

bot = TeleBot(CLIENT_BOT_TOKEN)


@bot.message_handler(commands=['start'])
def start_bot(message: Message) -> None:
    CustomerAuthorizationSrv(
        bot=bot,
        message=message
    )


@bot.message_handler(content_types=['text'])
def menu_buttons_bot(message: Message) -> None:
    if message.text == 'Следующая бронь':
        CustomerLastBookingSrv(
            bot=bot,
            message=message
        ).execute()


if __name__ == '__main__':
    bot.polling(none_stop=True)


# File: ./moderator_main.py
"""
Main file
"""
from telebot import TeleBot, types

from config import settings
from moderator_bot.src.services import ModeratorCreate, VerifiedOrganization


bot = TeleBot(settings.MODERATOR_BOT_TOKEN)  # type: ignore


@bot.message_handler(commands=['start'])
def main(message: types.Message):
    """
    Сообщение при запуске бота
    """
    bot.send_message(chat_id=message.chat.id,
                     text="Добро пожаловать а FixMaster для модераторов")
    ModeratorCreate(bot, message)

@bot.message_handler(commands=['test-call'])
def send_callback(message: types.Message):
    bot.send_message(
        chat_id=message.chat.id,
        text="text",
        reply_markup=types.InlineKeyboardMarkup().add(types.InlineKeyboardButton('Test', callback_data=f'organization_verify_{message.id}_false_43'))
    )


@bot.callback_query_handler(func=lambda call: True)
def callback_query(call: types.CallbackQuery):
    data: str = call.data
    

    if 'organization_verify_true' in data:
        organization_id = int(data.split('_')[-1])
        VerifiedOrganization(organization_id).verify_organization(True)
        verify_text = '\nВерифицирован ✅'
    elif 'organization_verify_false' in data:
        organization_id = int(data.split('_')[-1])
        VerifiedOrganization(organization_id).verify_organization(False)
        verify_text = '\nНе верифицирован ❌'
    else:
        verify_text = 'Не верифицирован ❌'

    bot.edit_message_text(
        chat_id=call.message.chat.id, 
        message_id=call.message.id,
        text=call.message.text + verify_text,
        )


if __name__ == '__main__':
    bot.polling(none_stop=True)

# File: ./tests.py
import os

project_dir = '.'  # Корень проекта
output_file = 'project_code.txt'
exclude_dirs = {'.venv','venv', '__pycache__', '.git', '.idea', '.mypy_cache', '.pytest_cache'}

extra_files = {'Dockerfile', 'docker-compose.yml', 'docker-compose.yaml'}
nginx_dirs = {'nginx'}
nginx_extensions = {'.conf'}

def should_include_file(file_path, file_name):
    if file_name.endswith('.py') and not file_name.endswith('.pyc'):
        return True
    if file_name in extra_files:
        return True
    if any(file_name.endswith(ext) for ext in nginx_extensions):
        return True
    if 'nginx' in file_path.split(os.sep):  # если файл внутри папки nginx
        return True
    return False

with open(output_file, 'w', encoding='utf-8') as outfile:
    for root, dirs, files in os.walk(project_dir):
        # Исключаем ненужные директории
        dirs[:] = [d for d in dirs if d not in exclude_dirs]

        for file in files:
            file_path = os.path.join(root, file)
            if should_include_file(file_path, file):
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        code = f.read()
                        outfile.write(f'# File: {file_path}\n')
                        outfile.write(code + '\n\n')
                except Exception as e:
                    print(f"Ошибка при чтении {file_path}: {e}")


# File: ./master_main.py
"""
Главный файл для запуска бота для матеров
"""

from telebot import TeleBot
from telebot.types import Message

from config.settings import MASTER_BOT_TOKEN
from master_bot.services import MasterVerifySrv, MasterCustomerSrv, MasterNextSessionSrv

bot = TeleBot(MASTER_BOT_TOKEN)


@bot.message_handler(commands=['start'])
def start_bot(message: Message) -> None:
    """ Логика при запуске бота """
    MasterVerifySrv(
        bot=bot,
        message=message
    )

@bot.message_handler(content_types=['text'])
def menu_button_handler(message: Message):
    text = message.text
    if message.text == 'Список мох клиентов':
        MasterCustomerSrv(
            bot=bot,
            message=message
        ).execute()
    elif message.text == 'Следующая бронь':
        MasterNextSessionSrv(
            bot=bot,
            message=message
        ).execute()

if __name__ == "__main__":
    bot.polling(none_stop=True)


# File: ./client_main.py
"""
Main file
"""
import logging
from telebot import TeleBot, types

from config import settings
from organization_bot.src.services import GetProfileTelebot

bot = TeleBot(settings.TELEGRAM_BOT_TOKEN)  # type: ignore

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

handler = logging.FileHandler('bot.log')
handler.setLevel(logging.DEBUG)


@bot.message_handler(commands=['start'])
def main(message: types.Message):
    """
    Сообщение при запуске бота
    """
    bot.send_message(chat_id=message.chat.id,
                     text="Введите номер телефона, на которую оформили бронь")
    GetProfileTelebot(bot, message)


@bot.message_handler(commands=['my_chat_id'])
def my_chat_id(message: types.Message):
    print(message.chat.id)
    bot.send_message(chat_id=message.chat.id,
                     text=f"{message.chat.id}")


if __name__ == '__main__':
    bot.polling(none_stop=True)


# File: ./Dockerfile
FROM python:3.11

ENV PYTHONUNBUFFERED=1
WORKDIR /bot/
COPY req.txt /bot/
RUN pip install -r req.txt
COPY . /bot/


# File: ./docker-compose.yml
version: '3'

services:
  organization_app:
    build: .
    restart: unless-stopped
    command: /bin/bash -c "python /bot/organization_main.py"
    network_mode: 'host'
    volumes:
      - ./:/bot/

  moderator_app:
    build: .
    restart: unless-stopped
    command: /bin/bash -c "python /bot/moderator_main.py"
    network_mode: 'host'
    volumes:
      - ./:/bot/

  master_app:
    build: .
    restart: unless-stopped
    command: /bin/bash -c "python /bot/master_main.py"
    network_mode: 'host'
    volumes:
      - ./:/bot/

  customer_app:
    build: .
    restart: unless-stopped
    command: /bin/bash -c "python /bot/customer_main.py"
    network_mode: 'host'
    volumes:
      - ./:/bot/

# File: ./organization_main.py
"""
Main file
"""
import os
import uuid

from telebot import TeleBot, types

from config import settings, cache
from config.settings import bucket_name, s3
from organization_bot.src.services import OrganizationCreate, MasterListSrv, MasterDetailSrv, \
    MasterDeleteSrv, MasterCreateSrv, MasterEditSrv, MasterServiceListSrv, MasterServiceListSrv, \
    MasterServiceDetailSrv, MasterServiceEditSrv, MasterServiceCreateSrv, MasterServiceDeleteSrv

bot = TeleBot(settings.ORGANIZATION_BOT_TOKEN)  # type: ignore


@bot.message_handler(commands=['start'])
def main(message: types.Message):
    """
    Сообщение при запуске бота
    """
    bot.send_message(chat_id=message.chat.id,
                     text="Добро пожаловать а FixMaster для организаций",
                     )
    OrganizationCreate(bot, message)


@bot.message_handler(content_types=['text'])
def get_organization_data_content(message: types.Message):
    if message.text == '📃 Список мастеров':
        MasterListSrv(bot=bot, message=message).execute()
    elif message.text == '👥 Список клиентов':
        pass
    elif message.text == "➕ Добавить мастера":
        MasterCreateSrv(bot=bot,
                        message=message)
    else:
        pass
        # ClientListSrv(bot=bot, message=message).execute()
    # elif message.text == :
    #     ServicesListSrv(bot=bot, message=message).execute()


@bot.callback_query_handler(func=lambda call: True)
def callback_query(call: types.CallbackQuery):
    data = call.data
    print(data)
    if 'masterlist' in data:
        MasterListSrv(
            bot=bot,
            message=call.message,
            call=True
        ).execute()
    elif 'masterdetail' in data:
        master_id = data.split('_')[-1]
        MasterDetailSrv(bot=bot,
                        master_id=int(master_id),
                        call=call,
                        ).execute()
    elif 'masterdelete' in data:
        master_id = data.split('_')[-1]
        MasterDeleteSrv(bot=bot,
                        master_id=int(master_id),
                        call=call,
                        ).execute()
    elif 'mastercrete' in data:
        MasterCreateSrv(bot=bot,
                        message=call.message)
    elif 'masteredit' in data:
        master_id = data.split('_')[-1]

        MasterEditSrv(
            bot=bot,
            message=call.message,
            master_id=int(master_id)
        )
    elif 'masterservices_list' in data:
        master_id = data.split('_')[-1]
        MasterServiceListSrv(
            bot=bot,
            message=call.message,
            master_id=int(master_id)
        ).execute()
    elif 'masterservice_detail' in data:
        service_id = data.split('_')[-1]
        print(service_id)
        MasterServiceDetailSrv(
            bot=bot,
            message=call.message,
            service_id=int(service_id)
        ).execute()
    elif 'masterservice_delete' in data:
        service_id = data.split('_')[-1]
        MasterServiceDeleteSrv(
            bot=bot,
            message=call.message,
            service_id=int(service_id)
        ).execute()

    elif 'masterservice_create' in data:
        master_id = data.split('_')[-1]
        MasterServiceCreateSrv(
            bot=bot,
            message=call.message,
            master_id=int(master_id)
        )
        ...
    elif 'mastereservice_edit' in data:
        service_id = data.split('_')[-1]
        MasterServiceEditSrv(
            bot=bot,
            message=call.message,
            service_id=int(service_id)
        )


@bot.message_handler(content_types=['photo'])
def photo(message: types.Message) -> None:
    file_id = message.photo[-1].file_id
    file_info = bot.get_file(file_id)
    downloaded_file = bot.download_file(file_info.file_path)

    path = f'photos/{message.from_user.username}/'
    if not os.path.isdir(path):
        os.mkdir(path)

    file_path = os.path.join(path, f"{str(uuid.uuid4())}.jpg")
    with open(file_path, 'wb') as file:
        file.write(downloaded_file)

    s3.upload_file(
        Filename=file_path,
        Bucket=bucket_name,
        Key=file_path
    )

    url = f"https://s3.timeweb.cloud/dea7d49e-ba387d71-db58-4c7f-8b19-e217f5775615/{file_path}"
    print(url)


if __name__ == '__main__':
    bot.polling(none_stop=True)


# File: ./master_bot/__init__.py


# File: ./master_bot/buttons.py
from telebot import types


def get_menu_buttons() -> types.ReplyKeyboardMarkup:
    menu_buttons = types.ReplyKeyboardMarkup()
    next_session = types.KeyboardButton('Следующая бронь')
    all_clients = types.KeyboardButton('Список мох клиентов')

    menu_buttons.row(next_session, all_clients)
    return menu_buttons


# File: ./master_bot/services.py
from telebot import TeleBot
from telebot.types import Message

from fixmaster_backend.client import FixMasterClient
from master_bot.buttons import get_menu_buttons

fix_master_client = FixMasterClient(
    api_key='test'
)


class MasterVerifySrv:

    def __init__(
            self,
            bot: TeleBot,
            message: Message
    ):
        self.bot = bot
        self.message = message
        self.telegram_id = message.chat.id
        self.start()

    def start(self) -> None:
        """
        Начало работы
        """
        self.bot.send_message(
            chat_id=self.telegram_id,
            text="Введеите код для авторизации."
        )
        self.bot.register_next_step_handler(self.message, self.check_code)

    def check_code(self, message: Message) -> None:
        """
        Проверка кода авторизации
        """

        self.code = message.text

        response = fix_master_client.master_verify(
            master_data={
                'code': self.code,
                'telegram_id': self.telegram_id
            }
        )

        if response.status_code == 200:
            self.bot.send_message(
                chat_id=self.telegram_id,
                text="Вы успешно авторизовались",
                reply_markup=get_menu_buttons()
            )
        elif response.status_code == 400:
            self.bot.send_message(
                chat_id=self.telegram_id,
                text=f"Вы неправильно ввели код.\n{response.json()['message']}",
            )
            self.bot.register_next_step_handler(message, self.check_code)
        else:
            print(response.text)
            self.bot.send_message(
                text=f"Неизвестная ошибка \n{response.status_code}\nПопробуйте еще раз или обратитесь к администратору",
                chat_id=self.telegram_id
            )
            self.bot.register_next_step_handler(message, self.check_code)


class MasterCustomerSrv:
    def __init__(
            self,
            bot: TeleBot,
            message: Message
    ):
        self.bot = bot
        self.message = message
        self.telegram_id = message.chat.id

    def get_master_customers(self) -> None:
        """ Получение списка клиентов мастера """
        response = fix_master_client.master_clients(self.telegram_id)

        if response.status_code == 200:
            self.customers = response.json()['data']
        else:
            self.customers = []

    def generate_customer_list_message(self) -> None:
        """ Генерация сообщения """
        self.message_obj = "Список клиентов:\n"

        for customer in self.customers:
            self.message_obj += f'@{customer.get("username")}\n'

    def send_customer_list_on_master(self) -> None:
        """ Отправка сообщения """
        self.bot.send_message(
            chat_id=self.telegram_id,
            text=self.message_obj
        )

    def execute(self) -> None:
        """ Выполнение всех команд """
        self.get_master_customers()
        self.generate_customer_list_message()
        self.send_customer_list_on_master()


class MasterNextSessionSrv:
    def __init__(
            self,
            bot: TeleBot,
            message: Message
    ):
        self.bot = bot
        self.message = message
        self.telegram_id = message.chat.id

    def get_last_booking(self) -> None:
        """ Получение данных о следующем броне """
        response = fix_master_client.master_last_booking(self.telegram_id)

        if response.status_code == 200:
            print(response.json())
            self.message_obj = response.json()['message']
        else:
            self.message_obj = "Неизвестная ошибка"

    def send_customer_list_on_master(self) -> None:
        """ Отправка сообщения """
        self.bot.send_message(
            chat_id=self.telegram_id,
            text=self.message_obj
        )

    def execute(self) -> None:
        """ Выполнение всех команд """
        self.get_last_booking()
        self.send_customer_list_on_master()


# File: ./fixmaster_backend/__init__.py
from fixmaster_backend.client import  FixMasterClient

__all__ = (
    'FixMasterClient'
)

# File: ./fixmaster_backend/client.py
from requests import get, post, delete, Response, put, patch


class FixMasterClient:
    BASE_URL = ['https://booking.fix-mst.ru/bot-api', 'http://localhost:8000/bot-api'][0]
    CREATE_ORGANIZATION_URL = BASE_URL + '/organization/create/'
    ORGANIZATION_TYPES_URL = 'https://booking.fix-mst.ru/api/organizations-types/'
    VERIFY_ORGANIZATION_URL = BASE_URL + '/organization/verify/'
    DELETE_MASTER_URL = BASE_URL + '/masters/'
    CREATE_MASTER_URL = BASE_URL + '/masters/'
    EDIT_MASTER_URL = BASE_URL + '/masters/'

    MASTER_VERIFY_URL = BASE_URL + '/master/verify/'
    MASTER_CUSTOMERS_URL = BASE_URL + '/master/{}/customers/'
    MASTER_SERVICES_URL = BASE_URL + '/masters/{}/services/'
    MASTER_LAST_BOOKING_URL = BASE_URL + '/master/{}/last-booking/'

    CUSTOMER_LAST_BOOKING_URL = BASE_URL + '/customer/{}/last-booking/'
    CUSTOMER_VERIFY_URL = BASE_URL + '/customer/verify/'
    CUSTOMER_CHECK_URL = BASE_URL + '/customer/check/'
    SERVICE_DETAIL_URL = BASE_URL + '/service/'

    GET_ORGANIZATION_BY_TELEGRAM_ID_URL = BASE_URL + '/organization/get-by-telegram_id/'
    GET_ORGANIZATION_DATA_BY_TELEGRAM_ID_URL = BASE_URL + '/organization-data/get-by-telegram_id/'
    GET_ACCOUNT_URL = BASE_URL + '/get-my-profile/'
    GET_MODERATOR_URL = BASE_URL + '/moderator/'

    def __init__(self, api_key: str):
        self.api_key = api_key
        print(api_key)
        self.headers = {
            'Content-Type': 'application/json',
            'Api-Key': api_key
        }

    def _post(self, request_url: str, body: dict):
        """
        Custom POST method
        """
        return post(
            request_url,
            headers=self.headers,
            data=body,
        )

    def _get(self, request_url: str, *args, **kwargs):
        """
        Custom POST method
        """

        return get(
            request_url,
            headers=self.headers,
            params=kwargs
        )

    def get_profile(self, **kwargs) -> dict:
        response = self._get(
            request_url=self.GET_ACCOUNT_URL,
            **kwargs
        )
        return response.json()

    def get_organization_types(self):
        response = self._get(
            self.ORGANIZATION_TYPES_URL
        )
        return response.json()

    def create_organization(self, organization_data: dict):
        response = post(
            self.CREATE_ORGANIZATION_URL,
            headers=self.headers,
            json=organization_data,
        )
        return response.json()

    def verify_organization(self, organization_id: int, verify: bool):
        response = post(
            self.VERIFY_ORGANIZATION_URL + f'{organization_id}/',
            headers=self.headers,
            json={
                'is_verify': verify
            },
        )
        return response

    def get_organization_by_telegram_id(self, telegram_id: str):
        response = get(
            self.GET_ORGANIZATION_BY_TELEGRAM_ID_URL + f'{telegram_id}',
            headers=self.headers,
        )
        return response

    def get_organization_data_by_telegram_id(self, telegram_id: str) -> Response:
        response = get(
            self.GET_ORGANIZATION_DATA_BY_TELEGRAM_ID_URL + f'{telegram_id}',
            headers=self.headers,
        )
        return response

    def get_moderator(self, moderator_data: dict) -> Response:
        response = post(
            self.GET_MODERATOR_URL,
            headers=self.headers,
            json=moderator_data,
        )
        return response

    def delete_master(self, master_id: int) -> int:
        response = delete(
            self.DELETE_MASTER_URL + f"{master_id}",
            headers=self.headers
        )
        return response.status_code

    def create_master(self, master_data: dict) -> Response:
        response = post(
            self.CREATE_MASTER_URL,
            headers=self.headers,
            json=master_data
        )
        print(response.json())
        return response

    def edit_master(self, master_data: dict, master_id: int) -> Response:
        response = patch(
            self.EDIT_MASTER_URL + f"{master_id}",
            headers=self.headers,
            json=master_data
        )
        return response

    def get_master_services(self, master_id: int) -> Response:
        response = get(
            self.MASTER_SERVICES_URL.format(master_id),
            headers=self.headers
        )
        return response

    def get_service_detail(self, service_id: int) -> Response:
        response = get(
            self.SERVICE_DETAIL_URL,
            headers=self.headers,
            params={
                'service_id': service_id
            }
        )
        return response

    def create_service(self, service_data: dict, master_id: int) -> Response:
        response = post(
            self.MASTER_SERVICES_URL.format(master_id),
            headers=self.headers,
            json=service_data,
        )
        print(response.json())
        return response

    def delete_service(self, service_id: int) -> Response:
        response = delete(
            self.SERVICE_DETAIL_URL,
            headers=self.headers,
            params={
                'service_id': service_id
            }
        )
        return response

    def edit_service(self, service_id: int, service_data: dict):
        response = patch(
            self.SERVICE_DETAIL_URL,
            json=service_data,
            headers=self.headers,
            params={
                'service_id': service_id
            }
        )

        return response

    def master_verify(self, master_data: dict) -> Response:
        response = post(
            self.MASTER_VERIFY_URL,
            headers=self.headers,
            json=master_data
        )
        return response

    def master_clients(self, telegram_id: int) -> Response:
        response = get(
            self.MASTER_CUSTOMERS_URL.format(telegram_id),
            headers=self.headers,
        )
        return response

    def master_last_booking(self, telegram_id: int | str) -> Response:
        response = get(
            self.MASTER_LAST_BOOKING_URL.format(telegram_id),
            headers=self.headers,
        )
        return response

    def customer_last_booking(self, telegram_id: int | str) -> Response:
        response = get(
            self.CUSTOMER_LAST_BOOKING_URL.format(telegram_id),
            headers=self.headers
        )
        return response

    def customer_verify(self, verify_data:dict) -> Response:
        response = get(
            self.CUSTOMER_VERIFY_URL,
            headers=self.headers,
            json=verify_data
        )
        return response

    def check_customer(self, telegram_id: int) -> Response:
        response = post(
            self.CUSTOMER_CHECK_URL,
            headers=self.headers,
            params={
                'telegram_id': telegram_id,
            }
        )
        return response

# File: ./organization_bot/src/__init__.py


# File: ./organization_bot/src/services.py
import dataclasses
import os
import re
import shutil
import uuid
from os import listdir
from os.path import isfile, join

from telebot import TeleBot
from telebot.types import (Message,
                           ReplyKeyboardMarkup,
                           KeyboardButton,
                           ReplyKeyboardRemove,
                           InlineKeyboardButton,
                           InlineKeyboardMarkup, CallbackQuery)

from config.redis import dict_get, dict_set
from fixmaster_backend import FixMasterClient
from config.settings import s3, bucket_name

fix_master_client = FixMasterClient(
    api_key='test'
)

organization_menu_markup = ReplyKeyboardMarkup()

master_list = KeyboardButton("📃 Список мастеров")
client_list = KeyboardButton('👥 Список клиентов')
add_master = KeyboardButton('➕ Добавить мастера')


organization_menu_markup.row(master_list, client_list)
organization_menu_markup.add(add_master)


@dataclasses.dataclass(slots=True, frozen=True)
class OrganizationData:
    phone_number: str
    main_image: bytes
    organization_type: int
    begin_time: str
    end_time: str
    work_schedule: str
    address: str


def get_organization_data(telegram_id: str | int) -> dict:
    response = fix_master_client.get_organization_data_by_telegram_id(
        telegram_id
    )
    if response.status_code == 200:
        print(response.status_code)
        return response.json()['data']

    return response.json()


def is_organization_exist(telegram_id: str) -> bool:
    response = fix_master_client.get_organization_by_telegram_id(
        telegram_id
    )
    if response.status_code == 200:
        return False
    else:
        return True


def is_phone_number(text: str):
    phone_pattern = re.compile(r'^\+?\d{1,4}?[-.\s]?(\(?\d{1,4}?\)?[-.\s]?)?\d{1,4}[-.\s]?\d{1,4}[-.\s]?\d{1,9}$')
    return bool(phone_pattern.match(text))


def get_organization_type_id(title: str) -> int:
    organization_type_id = list(filter(
        lambda x: x['title'] == title,
        fix_master_client.get_organization_types()['data']
    ))[0]
    return organization_type_id['id']


def generate_organization_types_buttons() -> ReplyKeyboardMarkup:
    """
    Получение кнопок для выбора типа организации
    """
    markup = ReplyKeyboardMarkup()
    organization_types = fix_master_client.get_organization_types()
    print(organization_types)
    for t in organization_types['data']:
        markup.add(KeyboardButton(text=f"{t['title']}"))
    return markup


def generate_all_times_buttons(default_time=4) -> ReplyKeyboardMarkup:
    markup = ReplyKeyboardMarkup(row_width=2)
    [markup.add(KeyboardButton(f"{i}:00")) for i in range(default_time, 20)]
    return markup


def generate_service_min_time_button():
    markup = ReplyKeyboardMarkup(row_width=2)
    [
        markup.add(
            KeyboardButton(f"{i}0 мин")
        ) for i in range(1, 10)
    ]
    return markup


def generate_master_detail_data(master_data: dict) -> str:
    result_message = ""
    master_data.pop('services')
    for key, value in master_data.items():
        result_message += f"{key}: {value}\n"
    print(result_message)
    return result_message


def generate_service_detail_data(service_data: dict) -> str:
    result_message = ""
    for key, value in service_data.items():
        result_message += f"{key}: {value}\n"
    print(result_message)
    return result_message


def get_master_services(master_id: int):
    response = fix_master_client.get_master_services(
        master_id
    )
    if response.status_code == 200:
        return response.json()['data']
    return response.text


def get_service_detail(service_id: int):
    response = fix_master_client.get_service_detail(
        service_id
    )
    if response.status_code == 200:
        return response.json()['data']
    return response.text


class GetProfileTelebot:
    def __init__(self, bot: TeleBot, message: Message):
        self.bot = bot
        self.bot.register_next_step_handler(message, self.get_number)

    def get_number(self, message: Message):
        """ Получение данных телефона """

        try:
            self.phone_number = message.text
            self.bot.send_message(
                chat_id=message.chat.id,
                text="Теперь введите код"
            )
        except:
            self.bot.send_message(
                chat_id=message.chat.id,
                text="Вы ввели неправильный формат\nПопробуйте еще раз.\nПример: 89990001122"
            )
            self.bot.register_next_step_handler(message, self.get_number)
            return

    def get_code(self, message: Message):
        response_data = fix_master_client.get_profile(
            phone_number=self.phone_number,
            user_keyword=self.user_keyword,
            telegram_id=message.chat.id,
            username=message.from_user.username
        )
        self.bot.send_message(
            chat_id=message.chat.id,
            text=response_data.get('message')
        )


class OrganizationCreate:
    """ Логика создания организаций """

    def __init__(self, bot: TeleBot, message: Message):
        self.bot = bot
        self.message = message
        self.organization = dict()
        if is_organization_exist(self.message.chat.id):
            self._send(
                text="Вы уже зарегистрированы в системе",
                reply_markup=organization_menu_markup
            )
            self._send(
                text=get_organization_data(self.message.chat.id).get('title', 'Cle')
            )
            return
        self.start(message)

    def _send(self, text, **kwargs):
        message = self.bot.send_message(
            chat_id=self.message.chat.id,
            text=text,
            **kwargs
        )
        return message

    def _step(self, message, func):
        self.bot.register_next_step_handler(message, func)

    def start(self, message):
        self._send(
            text="Введите название \n",
            reply_markup=ReplyKeyboardRemove()
        )

        self._step(message, self.get_title)

    def get_title(self, message: Message):
        self.organization['title'] = message.text
        self._send(
            text="Введите номер телефона горячей линии организации\nПример: 82930703023",
            reply_markup=ReplyKeyboardRemove()
        )

        self._step(message, self.get_number)

    def get_number(self, message: Message):
        while True:
            try:
                self.organization['contact_phone'] = message.text
                if not is_phone_number(self.organization['contact_phone']):
                    self._send(text="Введите корректный номер телефона")
                    self._step(message, self.get_number)
                    return

                # next msg
                self._send(
                    text="Введите главное изображене"
                )
                self._step(message, self.get_main_image)
                break
            except TypeError:
                self._send(
                    text="Введите корректный номер телефона"
                )
                self._step(message, self.get_number)
                return

    def get_main_image(self, message: Message):
        while True:
            try:
                download_message = self._send(
                    'Загружаем...'
                )
                file_id = message.photo[-1].file_id
                file_info = self.bot.get_file(file_id)
                downloaded_file = self.bot.download_file(file_info.file_path)
                with open(file_info.file_path, 'wb') as file:
                    file.write(downloaded_file)

                s3.upload_file(
                    Filename=file_info.file_path,
                    Bucket=bucket_name,
                    Key=file_info.file_path
                )

                self.organization[
                    'main_image_url'
                ] = f"https://s3.timeweb.cloud/dea7d49e-ba387d71-db58-4c7f-8b19-e217f5775615/{file_info.file_path}"
                break

            except Exception as _:
                print(_.args)
                self._send(
                    text="Введите корректное изображение",
                )
                self._step(message, self.get_main_image)
                return
        # msg
        self.bot.edit_message_text(
            chat_id=download_message.chat.id,
            message_id=download_message.id,
            text="Отлично!\n",
        )
        self._send(
            text='Выберите фотографии вашей организации!'
        )
        self._step(message, self.get_organization_gallery)

    def get_organization_gallery(self, message):
        try:
            file_id = message.photo[-1].file_id
            file_info = self.bot.get_file(file_id)
            downloaded_file = self.bot.download_file(file_info.file_path)

            path = f'photos/{message.from_user.username}/'
            if not os.path.isdir(path):
                os.mkdir(path)

            file_path = os.path.join(path, f"{str(uuid.uuid4())}.jpg")
            with open(file_path, 'wb') as file:
                file.write(downloaded_file)

            s3.upload_file(
                Filename=file_path,
                Bucket=bucket_name,
                Key=file_path
            )
            self._send(
                text='Теперь выберите тип вашей организации!',
                reply_markup=generate_organization_types_buttons()
            )
            self._step(message, self.get_organization_type)
        except:
            self._send(
                text='Выберите корректные фотографии',
            )
            self._step(message, self.get_organization_type)
    def get_organization_type(self, message: Message):
        self.organization['organization_type_id'] = get_organization_type_id(message.text)

        # msg
        self._send(
            text="Выберите начало рабочего дня",
            reply_markup=generate_all_times_buttons()
        )
        self._step(message, self.get_begin_time)

    def get_begin_time(self, message: Message):
        self.organization['time_begin'] = message.text

        # msg
        self._send(
            text="А теперь выберите конец рабочего дня",
            reply_markup=generate_all_times_buttons()
        )
        self._step(message, self.get_end_time)

    def get_end_time(self, message: Message):
        self.organization['time_end'] = message.text

        # msg
        self._send(
            text="Введите график работы\nПример: 5/2, ПН-ПТ и тд.",
            reply_markup=ReplyKeyboardRemove()
        )
        self._step(message, self.get_work_schedule)

    def get_work_schedule(self, message: Message):
        self.organization['work_schedule'] = message.text

        # msg
        self._send(
            text="Введите адрес организации",
            reply_markup=ReplyKeyboardRemove()
        )
        self._step(message, self.get_address)

    def get_address(self, message: Message):
        self.organization['address'] = message.text

        self._send(
            text="Отлично! Заявка на верификацию отправлена!\nЖдите ответа",
            reply_markup=ReplyKeyboardRemove()
        )
        print(self.organization)
        self.organization['telegram_id'] = self.message.chat.id
        path = f'photos/{message.from_user.username}/'
        s3_url = "https://s3.timeweb.cloud/dea7d49e-ba387d71-db58-4c7f-8b19-e217f5775615/" + path
        self.organization['gallery'] = [s3_url + f for f in listdir(path) if isfile(join(path, f))]

        fix_master_client.create_organization(self.organization)
        print(self.organization)
        shutil.rmtree(path)


class MasterListSrv:

    def __init__(self, bot: TeleBot, message: Message, call: CallbackQuery = None):
        self.bot = bot
        self.message = message
        self.call = call

    def _send(self, text, **kwargs):
        message = self.bot.send_message(
            chat_id=self.message.chat.id,
            text=text,
            **kwargs
        )
        return message

    def generate_master_list_buttons(self):
        self.master_list = get_organization_data(self.message.chat.id)['masters']
        self.master_list_buttons = InlineKeyboardMarkup()
        [self.master_list_buttons.add(InlineKeyboardButton(text=f"{i.get('name')} {i.get('surname')}",
                                                           callback_data=f"masterdetail_{i.get('id')}"))
         for i in self.master_list]

    def execute(self):

        self.generate_master_list_buttons()
        if self.call:
            self.bot.edit_message_text(
                text=f"Список мастеров:\nУ вас {len(self.master_list)} мастеров",
                reply_markup=self.master_list_buttons,
                message_id=self.message.id,
                chat_id=self.message.chat.id
            )
        else:
            self._send(
                text=f"Список мастеров:\nУ вас {len(self.master_list)} мастеров",
                reply_markup=self.master_list_buttons,
            )
        return None


class MasterDetailSrv:

    def __init__(
            self,
            bot: TeleBot,
            call: CallbackQuery,
            master_id: int
    ):
        self.bot = bot
        self.message = call.message
        self.call_data = call.data
        self.master_id = master_id

    def _send(self, text, **kwargs):
        message = self.bot.send_message(
            chat_id=self.message.chat.id,
            text=text,
            **kwargs
        )
        return message

    def get_master_data(self):
        try:
            self.master_data = list(filter(
                lambda x: x['id'] == self.master_id,
                get_organization_data(self.message.chat.id)['masters']
            ))[0]
        except IndexError:
            self.master_data = None

    def generate_master_detail_buttons(self):
        self.master_detail_buttons = InlineKeyboardMarkup()
        edit_button = InlineKeyboardButton('Изменить', callback_data=f"masteredit_{self.master_data.get('id')}")
        delete_button = InlineKeyboardButton('Удалить', callback_data=f"masterdelete_{self.master_data.get('id')}")
        master_services_button = InlineKeyboardButton('Список улуг',
                                                      callback_data=f"masterservices_list_{self.master_data.get('id')}")
        back_button = InlineKeyboardButton(text='Назад', callback_data=f"backmasterlist_{self.message.chat.id}")
        self.master_detail_buttons.add(edit_button)
        self.master_detail_buttons.add(delete_button)
        self.master_detail_buttons.add(master_services_button)
        self.master_detail_buttons.add(back_button)

    def execute(self):
        self.get_master_data()
        if self.master_data:
            self.generate_master_detail_buttons()
            self.bot.edit_message_text(
                text=generate_master_detail_data(self.master_data),
                reply_markup=self.master_detail_buttons,
                message_id=self.message.id,
                chat_id=self.message.chat.id
            )

        return None


class MasterDeleteSrv:

    def __init__(
            self,
            bot: TeleBot,
            call: CallbackQuery,
            master_id: int
    ):
        self.bot = bot
        self.message = call.message
        self.call_data = call.data
        self.master_id = master_id

    def generate_master_list_buttons(self):
        self.master_list = get_organization_data(self.message.chat.id)['masters']
        self.master_list_buttons = InlineKeyboardMarkup()
        [self.master_list_buttons.add(InlineKeyboardButton(text=f"{i.get('name')} {i.get('surname')}",
                                                           callback_data=f"masterdetail_{i.get('id')}"))
         for i in self.master_list]

    def delete_master(self):
        self.bot.edit_message_text(
            text="Удаляем мастера",
            message_id=self.message.id,
            chat_id=self.message.chat.id
        )
        fix_master_client.delete_master(
            self.master_id
        )

    def execute(self):
        self.delete_master()
        self.generate_master_list_buttons()
        self.bot.edit_message_text(
            text=f"Список мастеров:\nУ вас {len(self.master_list)} мастеров",
            reply_markup=self.master_list_buttons,
            message_id=self.message.id,
            chat_id=self.message.chat.id
        )
        return None


class MasterCreateSrv:

    def __init__(self, bot: TeleBot, message: Message):
        self.bot = bot
        self.message = message
        self.master_data = dict()

        self.start(message)

    def _send(self, text, **kwargs):
        message = self.bot.send_message(
            chat_id=self.message.chat.id,
            text=text,
            **kwargs
        )
        return message

    def _step(self, message, func):
        self.bot.register_next_step_handler(message, func)

    def start(self, message):

        self._send(
            text="Введите имя мастера\n",
            reply_markup=ReplyKeyboardRemove()
        )

        self._step(message, self.get_name)

    def get_name(self, message: Message):
        self.master_data['name'] = message.text
        self._send(
            text="Введите фамилию мастера",
            reply_markup=ReplyKeyboardRemove()
        )

        self._step(message, self.get_surname)

    def get_surname(self, message: Message):
        if message.text == 'Пропустить':
            self._step(message, self.get_image)
            return
        self.master_data['surname'] = message.text

        # next msg
        self._send(
            text="Введите фотографию мастера"
        )
        self._step(message, self.get_image)

    def get_image(self, message: Message):
        while True:
            try:

                download_message = self._send(
                    'Загружаем...'
                )
                file_id = message.photo[-1].file_id
                print("Получаем файл", file_id)

                file_info = self.bot.get_file(file_id)
                print("Получаем файл", file_info.__dict__)

                downloaded_file = self.bot.download_file(file_info.file_path)
                print("Началась загрузка фотографии загрузилась 1")
                with open(file_info.file_path, 'wb') as file:
                    file.write(downloaded_file)
                print("Началась загрузка фотографии загрузилась 2")
                s3.upload_file(
                    Filename=file_info.file_path,
                    Bucket=bucket_name,
                    Key=file_info.file_path
                )
                print("Фотография загрузилась")

                self.master_data[
                    'image_url'] = f"https://s3.timeweb.cloud/dea7d49e-ba387d71-db58-4c7f-8b19-e217f5775615/{file_info.file_path}"
                break

            except Exception as _:
                self._send(
                    text="Введите корректное изображение",
                )
                print(_.args)
                self._step(message, self.get_image)
                return
        # msg
        self.bot.edit_message_text(
            chat_id=download_message.chat.id,
            message_id=download_message.id,
            text="Отлично!\n",

        )
        self._send(
            text="Мастер создан!",
            reply_markup=organization_menu_markup
        )
        self.master_data['organization_id'] = get_organization_data(self.message.chat.id).get('id')
        response = fix_master_client.create_master(self.master_data)
        code = response.json()['data']
        self._send(
            text=f"Перешлите это сообщение мастеру\nhttps://t.me/fix_master_employee_bot/?text={code}"
        )


class MasterEditSrv:
    def __init__(self, bot: TeleBot, message: Message, master_id: int):
        self.bot = bot
        self.message = message
        self.master_data = dict()
        self.master_id = master_id
        self.start(message)

    def _send(self, text, **kwargs):
        message = self.bot.send_message(
            chat_id=self.message.chat.id,
            text=text,
            **kwargs
        )
        return message

    def _step(self, message, func):

        self.bot.register_next_step_handler(message, func)

    def start(self, message):
        self.skip_button_markup = ReplyKeyboardMarkup(resize_keyboard=True, row_width=1)
        self.skip_button_markup.add(
            KeyboardButton(text='Не изменять')
        )
        self._send(
            text="Введите имя мастера\nИли нажмите 'Не изменять'",
            reply_markup=self.skip_button_markup
        )

        self._step(message, self.get_name)

    def get_name(self, message: Message):

        if message.text == 'Не изменять':
            self._send(
                text="Введите фамилию мастера",
                reply_markup=self.skip_button_markup
            )
            self._step(message, self.get_surname)
            return
        else:
            self.master_data['name'] = message.text
            self._send(
                text="Введите фамилию мастера",
                reply_markup=self.skip_button_markup
            )

            self._step(message, self.get_surname)

    def get_surname(self, message: Message):
        if message.text == 'Не изменять':
            self._send(
                text="Введите фотографию мастера"
            )
            self._step(message, self.get_image)
            return
        self.master_data['surname'] = message.text

        # next msg
        self._send(
            text="Введите фотографию мастера"
        )
        self._step(message, self.get_image)

    def get_image(self, message: Message):
        download_message = None
        while True:
            try:

                if message.text == 'Не изменять':
                    break

                download_message = self._send(
                    'Загружаем...'
                )
                file_id = message.photo[-1].file_id
                print("Получаем файл", file_id)

                file_info = self.bot.get_file(file_id)
                print("Получаем файл", file_info.__dict__)

                downloaded_file = self.bot.download_file(file_info.file_path)
                print("Началась загрузка фотографии загрузилась 1")
                with open(file_info.file_path, 'wb') as file:
                    file.write(downloaded_file)
                print("Началась загрузка фотографии загрузилась 2")
                s3.upload_file(
                    Filename=file_info.file_path,
                    Bucket=bucket_name,
                    Key=file_info.file_path
                )
                print("Фотография загрузилась")
                self.master_data[
                    'image_url'] = f"https://s3.timeweb.cloud/dea7d49e-ba387d71-db58-4c7f-8b19-e217f5775615/{file_info.file_path}"
                break

            except Exception as _:
                self._send(
                    text="Введите корректное изображение",
                )
                print(_.args)

                self._step(message, self.get_image)
                return

        # msg
        if download_message:
            self.bot.edit_message_text(
                chat_id=download_message.chat.id,
                message_id=download_message.id,
                text="Отлично!\n",
            )
        self._send(
            text="Мастер Изменен!",
            reply_markup=organization_menu_markup
        )
        self.master_data['organization_id'] = get_organization_data(self.message.chat.id).get('id')
        fix_master_client.edit_master(self.master_data, self.master_id)


class MasterServiceListSrv:

    def __init__(self,
                 bot: TeleBot,
                 message: Message,
                 master_id: int):
        self.bot = bot
        self.message = message
        self.master_id = master_id

    def _send(self, text, **kwargs):
        message = self.bot.send_message(
            chat_id=self.message.chat.id,
            text=text,
            **kwargs
        )
        return message

    def get_services_list(self):
        self.master_services = get_master_services(self.master_id)

    def generate_service_list_buttons(self):
        self.services_list_buttons = InlineKeyboardMarkup()
        self.services_list = self.master_services
        [
            self.services_list_buttons.add(
                InlineKeyboardButton(
                    f"{i.get('title')}",
                    callback_data='masterservice_detail_{}'.format(i.get('id'))
                )
            )
            for i in self.services_list
        ]
        self.services_list_buttons.add(
            InlineKeyboardButton(
                text='Добавить услугу',
                callback_data='masterservice_create_{}'.format(self.master_id)
            )
        )
        self.services_list_buttons.add(
            InlineKeyboardButton(
                'Назад',
                callback_data='masterdetail_{}'.format(self.master_id)
            )
        )

    def execute(self):
        self.get_services_list()
        self.generate_service_list_buttons()
        self.bot.edit_message_text(
            text=f"Список услуг мастера:\nУ мастера {len(self.services_list)} услуг",
            reply_markup=self.services_list_buttons,
            message_id=self.message.id,
            chat_id=self.message.chat.id
        )
        return None


class MasterServiceDetailSrv:

    def __init__(self,
                 bot: TeleBot,
                 message: Message,
                 service_id: int):
        self.bot = bot
        self.message = message
        self.service_id = service_id

    def _send(self, text, **kwargs):
        message = self.bot.send_message(
            chat_id=self.message.chat.id,
            text=text,
            **kwargs
        )
        return message

    def get_service_detail(self):
        self.service_detail = get_service_detail(self.service_id)

    def generate_service_list_buttons(self):
        self.service_detail_buttons = InlineKeyboardMarkup()
        edit_button = InlineKeyboardButton('Изменить',
                                           callback_data=f"mastereservice_edit_{self.service_detail.get('id')}")
        delete_button = InlineKeyboardButton('Удалить',
                                             callback_data=f"masterservice_delete_{self.service_detail.get('id')}")
        back_button = InlineKeyboardButton('Назад',
                                           callback_data=f"masterservices_list_{self.service_detail.get('master_id')}")
        self.service_detail_buttons.add(edit_button)
        self.service_detail_buttons.add(delete_button)
        self.service_detail_buttons.add(back_button)

    def execute(self):
        self.get_service_detail()
        self.generate_service_list_buttons()
        self.bot.edit_message_text(
            text=" услуг",
            chat_id=self.message.chat.id,
            message_id=self.message.id,
            reply_markup=self.service_detail_buttons
        )
        return None


class MasterServiceCreateSrv:
    def __init__(self,
                 bot: TeleBot,
                 message: Message,
                 master_id: int):
        self.bot = bot
        self.message = message
        self.service_data = dict()
        self.master_id = master_id
        self.start(message)

    def _send(self, text, **kwargs):
        message = self.bot.send_message(
            chat_id=self.message.chat.id,
            text=text,
            **kwargs
        )
        return message

    def _step(self, message, func):
        self.bot.register_next_step_handler(message, func)

    def start(self, message):
        self._send(
            text="Введите название услуги \n",
            reply_markup=ReplyKeyboardRemove()
        )

        self._step(message, self.get_title)

    def get_title(self, message: Message):
        self.service_data['title'] = message.text
        self._send(
            text="Введите короткое описание услуги",
            reply_markup=ReplyKeyboardRemove()
        )

        self._step(message, self.get_description)

    def get_description(self, message: Message):
        self.service_data['short_description'] = message.text

        # next msg
        self._send(
            text="Выберите длительность услуги",
            reply_markup=generate_service_min_time_button()
        )
        self._step(message, self.get_min_time)

    def get_min_time(self, message: Message):
        # msg
        try:
            if 'мин' in message.text:
                time = message.text.replace('мин', '')
                int(time)
                self.service_data['min_time'] = time

        except ValueError:
            self._send(
                text="Выберите число из списка"
            )
            self._step(message, self.get_min_time)
            return
        self._send(
            text="Введите стоимость услуги в рублях",
            reply_markup=ReplyKeyboardRemove()
        )
        self._step(message, self.get_price)

    def get_price(self, message: Message):
        self.service_data['price'] = message.text
        try:
            int(message.text)
        except ValueError:
            self._send(
                text="Введите корректную стоимость "
            )
            self._step(message, self.get_price)
            return

        self._send(
            text="Услуга создана",
            reply_markup=organization_menu_markup
        )
        self.service_data['master_id'] = self.master_id
        fix_master_client.create_service(self.service_data, self.master_id)


class MasterServiceEditSrv:
    def __init__(self,
                 bot: TeleBot,
                 message: Message,
                 service_id: int):
        self.bot = bot
        self.message = message
        self.service_data = dict()
        self.service_id = service_id
        self.start(message)

    def _send(self, text, **kwargs):
        message = self.bot.send_message(
            chat_id=self.message.chat.id,
            text=text,
            **kwargs
        )
        return message

    def _step(self, message, func):
        self.bot.register_next_step_handler(message, func)

    def start(self, message):
        self.skip_button_markup = ReplyKeyboardMarkup(resize_keyboard=True, row_width=1)
        self.skip_button_markup.add(
            KeyboardButton(text='Не изменять')
        )
        self._send(
            text="Введите название услуги \n или нажмине 'Не изменять'",
            reply_markup=self.skip_button_markup
        )

        self._step(message, self.get_title)

    def get_title(self, message: Message):
        if message.text == 'Не изменять':
            self._send(
                text="Введите короткое описание услуги",
                reply_markup=self.skip_button_markup
            )
            self._step(message, self.get_description)
            return
        self.service_data['title'] = message.text
        self._send(
            text="Введите короткое описание услуги",
            reply_markup=self.skip_button_markup
        )

        self._step(message, self.get_description)

    def get_description(self, message: Message):
        new_skip_button_markup = generate_service_min_time_button()
        new_skip_button_markup.add(KeyboardButton(text='Не изменять'))
        if message.text == 'Не изменять':
            self._send(
                text="Выберите длительность услуги",
                reply_markup=new_skip_button_markup
            )
            self._step(message, self.get_min_time)
            return
        self.service_data['short_description'] = message.text

        # next msg
        self._send(
            text="Выберите длительность услуги",
            reply_markup=generate_service_min_time_button()
        )
        self._step(message, self.get_min_time)

    def get_min_time(self, message: Message):
        if message.text == 'Не изменять':
            self._send(
                text="Введите стоимость услуги в рублях",
                reply_markup=self.skip_button_markup
            )
            self._step(message, self.get_price)
            return
        # msg
        try:
            if 'мин' in message.text:
                time = message.text.replace('мин', '')
                int(time)
                self.service_data['min_time'] = time

        except ValueError:
            self._send(
                text="Выберите число из списка"
            )
            self._step(message, self.get_min_time)
            return
        self._send(
            text="Введите стоимость услуги в рублях",
            reply_markup=ReplyKeyboardRemove()
        )
        self._step(message, self.get_price)

    def get_price(self, message: Message):
        if message.text == 'Не изменять':
            pass
        else:
            self.service_data['price'] = message.text
            try:
                int(message.text)
            except ValueError:
                self._send(
                    text="Введите корректную стоимость "
                )
                self._step(message, self.get_price)
                return

        self._send(
            text="Услуга изменена",
            reply_markup=organization_menu_markup
        )
        fix_master_client.edit_service(service_id=self.service_id, service_data=self.service_data)


class MasterServiceDeleteSrv:
    def __init__(self,
                 bot: TeleBot,
                 message: Message,
                 service_id: int):
        self.bot = bot
        self.message = message
        self.service_id = service_id

    def delete_service(self):
        fix_master_client.delete_service(service_id=self.service_id)

    def execute(self):
        self.delete_service()
        self.bot.edit_message_text(
            text="Услуга удалена",
            chat_id=self.message.chat.id,
            message_id=self.message.id,
        )
        return None


# File: ./config/__init__.py
from config.redis import cache

__all__ = ('cache',)

# File: ./config/redis.py
import pickle

import redis

cache = redis.Redis(
    host='localhost',
)


def dict_set(name: str, data: dict):
    cache.set(name, pickle.dumps(data))


def dict_get(name: str) -> dict:
    if value := cache.get(name):
        return pickle.loads(value)


# File: ./config/settings.py
"""
Project settings
"""
import os
from pathlib import Path
import boto3

from dotenv import load_dotenv

load_dotenv()

CLIENT_BOT_TOKEN = os.getenv('CLIENT_BOT_TOKEN')
MASTER_BOT_TOKEN = os.getenv('MASTER_BOT_TOKEN')
ORGANIZATION_BOT_TOKEN = os.getenv('ORGANIZATION_BOT_TOKEN')
MODERATOR_BOT_TOKEN = os.getenv('MODERATOR_BOT_TOKEN')

AWS_ACCESS_KEY = os.getenv('AWS_ACCESS_KEY')
AWS_SECRET_KEY = os.getenv('AWS_SECRET_KEY')
AWS_BUCKET_NAME = os.getenv('AWS_BUCKET_NAME')
AWS_UPLOAD_URL = os.getenv('AWS_UPLOAD_URL')
AWS_CUSTOM_URL = os.getenv('AWS_CUSTOM_URL')

bucket_name = AWS_BUCKET_NAME

session = boto3.Session(
    aws_access_key_id=AWS_ACCESS_KEY,
    aws_secret_access_key=AWS_SECRET_KEY,
    region_name="ru-1",
)

s3 = session.client(
    "s3", endpoint_url=AWS_UPLOAD_URL)
print(s3)


# File: ./moderator_bot/__init__.py


# File: ./moderator_bot/src/__init__.py


# File: ./moderator_bot/src/services.py
from telebot import TeleBot
from telebot.types import Message, ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove

from fixmaster_backend import FixMasterClient

fix_master_client = FixMasterClient(
    api_key='test'
)


class ModeratorCreate:
    """ Логика создания организаций """

    def __init__(self, bot: TeleBot, message: Message):
        self.bot = bot
        self.message = message
        self.moderator = dict()
        self.moderator['telegram_id'] = message.chat.id
        self._send(
            text="Введите логин \n",
            reply_markup=ReplyKeyboardRemove()
        )
        self.start(message)

    def _send(self, text, **kwargs):
        self.bot.send_message(
            chat_id=self.message.chat.id,
            text=text,
            **kwargs
        )

    def _step(self, message, func):
        self.bot.register_next_step_handler(message, func)

    def start(self, message):
        
        self._step(
            message,
            self.get_login
        )

    def get_login(self, message: Message):
        login = message.text
        self.moderator['login'] = login
        self._send(
            text="Введите код"
        )
        self._step(
            message, self.get_code
        )

    def get_code(self, message: Message):
        while True:
            code = message.text
            self.moderator['code'] = code
            response = fix_master_client.get_moderator(
                    self.moderator
                )
            
            print(response.status_code)
            print(response.json())
            if response.json():
                if response.json()['code'] == 201:
                    self._send(
                        text=response.json()['message']
                    )
                    break
                elif response.json()['code'] == 404:
                    self._send(
                        text=response.json()['message']
                    )
                    self._step(
                        message,
                        self.get_code
                    )
                    return
                elif response.json()['code'] == 400:
                    self._send(
                        text=response.json()['message']
                    )
                    self._send(
                        text="Введите логин еще раз"
                    )
                    self._step(
                        message,
                        self.get_login
                    )
                    return
                elif response.json()['code'] == 440:
                    self._send(
                        text=response.json()['message']
                    )
                    return
                
                else:
                    self._send(
                        text=response.json()['message']
                    )
                    self._step(
                        message,
                        self.get_code
                    )
                    return



class VerifiedOrganization:
    def __init__(self, organization_id: int):
        self.organization_id = organization_id

    def verify_organization(self, verify: bool):
        fix_master_client.verify_organization(
            organization_id=self.organization_id,
            verify=verify
        )
    


# File: ./customer_bot/__init__.py


# File: ./customer_bot/services.py
from telebot.types import Message, ReplyKeyboardMarkup, KeyboardButton, WebAppInfo
from telebot import TeleBot

from fixmaster_backend import FixMasterClient

fix_master_client = FixMasterClient(
    api_key='test'
)



def web_app_keyboard(user_id: int): #создание клавиатуры с webapp кнопкой
    menu_buttons = ReplyKeyboardMarkup(row_width=1)
    last_booking = KeyboardButton("Следующая бронь")
    webAppTest = WebAppInfo(f"https://booking.fix-mst.ru/#/?user_id={user_id}") #создаем webappinfo - формат хранения url

    one_butt = KeyboardButton(text="Забронировать еще", web_app=webAppTest) #создаем кнопку типа webapp
    menu_buttons.row(one_butt, last_booking) #добавляем кнопки в клавиатуру

    return menu_buttons #возвращаем клавиатуру

def check_authorization(telegram_id: int | str):
    response = fix_master_client.check_customer(telegram_id)
    return response.status_code == 200


class CustomerAuthorizationSrv:
    def __init__(
            self,
            bot: TeleBot,
            message: Message

    ):
        self.telegram_id = message.chat.id
        self.bot = bot

        self.bot.send_message(
            chat_id=self.telegram_id,
            text="Добро пожаловать в FixMaster для клиентов\n"
        )
        if not check_authorization(self.telegram_id):
            self.bot.send_message(
                chat_id=self.telegram_id,
                text="Введите код для авторизации\n"
            )
            self.bot.register_next_step_handler(message, self.start)
        else:

            self.bot.send_message(
                chat_id=self.telegram_id,
                text="Вы уже авторизованы в системе",
                reply_markup=web_app_keyboard(self.telegram_id)
            )

    def start(self, message: Message):
        code = message.text

        response = fix_master_client.customer_verify(
            verify_data={
                'telegram_id': self.telegram_id,
                'code': code,
                'username': message.from_user.username
            }
        )
        print(response.text)
        if response.status_code == 200:
            self.bot.send_message(
                chat_id=self.telegram_id,
                text=response.json()['message'],
                reply_markup=web_app_keyboard(self.telegram_id)
            )
            return
        self.bot.send_message(
            chat_id=self.telegram_id,
            text=response.json()['message']
        )


class CustomerLastBookingSrv:
    def __init__(
            self,
            bot: TeleBot,
            message: Message

    ):
        self.telegram_id = message.chat.id
        self.bot = bot

    def get_last_booking(self) -> None:
        """ Получение последней брони клиента """
        response = fix_master_client.customer_last_booking(
            telegram_id=self.telegram_id
        )

        self.bot.send_message(
            chat_id=self.telegram_id,
            text=response.json()['message']
        )


    def execute(self) -> None:
        """ Выполнение команд """
        self.get_last_booking()




